# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2016, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-10-30 10:44+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../Doc/library/unittest.rst:2
msgid ":mod:`unittest` --- Unit testing framework"
msgstr ":mod:`unittest` --- *Framework* de tests unitaires"

#: ../Doc/library/unittest.rst:13
msgid ""
"(If you are already familiar with the basic concepts of testing, you might "
"want to skip to :ref:`the list of assert methods <assert-methods>`.)"
msgstr ""
"(Si vous êtes déjà familier des concepts de base concernant les tests, vous "
"pouvez souhaiter passer à :ref:`la liste des méthodes <assert-methods>`.)"

#: ../Doc/library/unittest.rst:16
msgid ""
"The Python unit testing framework, sometimes referred to as \"PyUnit,\" is a "
"Python language version of JUnit, by Kent Beck and Erich Gamma. JUnit is, in "
"turn, a Java version of Kent's Smalltalk testing framework.  Each is the de "
"facto standard unit testing framework for its respective language."
msgstr ""

#: ../Doc/library/unittest.rst:21
msgid ""
":mod:`unittest` supports test automation, sharing of setup and shutdown code "
"for tests, aggregation of tests into collections, and independence of the "
"tests from the reporting framework.  The :mod:`unittest` module provides "
"classes that make it easy to support these qualities for a set of tests."
msgstr ""

#: ../Doc/library/unittest.rst:26
msgid "To achieve this, :mod:`unittest` supports some important concepts:"
msgstr ""

#: ../Doc/library/unittest.rst:32
msgid "test fixture"
msgstr "aménagement de test (*fixture*)"

#: ../Doc/library/unittest.rst:29
msgid ""
"A :dfn:`test fixture` represents the preparation needed to perform one or "
"more tests, and any associate cleanup actions.  This may involve, for "
"example, creating temporary or proxy databases, directories, or starting a "
"server process."
msgstr ""
"Un :dfn:`aménagement de test (*fixture*)` désigne la préparation nécessaire "
"au déroulement d'un ou plusieurs tests, et toutes les actions de nettoyage "
"associées. Cela peut concerner, par exemple, la création de bases de données "
"temporaires ou mandataires, de répertoires, ou le démarrage d'un processus "
"serveur."

#: ../Doc/library/unittest.rst:37
msgid "test case"
msgstr "scénario de test"

#: ../Doc/library/unittest.rst:35
msgid ""
"A :dfn:`test case` is the smallest unit of testing.  It checks for a "
"specific response to a particular set of inputs.  :mod:`unittest` provides a "
"base class, :class:`TestCase`, which may be used to create new test cases."
msgstr ""

#: ../Doc/library/unittest.rst:41
msgid "test suite"
msgstr "suite de tests"

#: ../Doc/library/unittest.rst:40
msgid ""
"A :dfn:`test suite` is a collection of test cases, test suites, or both.  It "
"is used to aggregate tests that should be executed together."
msgstr ""
"Une :dfn:`suite de tests` est une collection de scénarios de test, de suites "
"de tests ou les deux. Cela sert à regrouper les tests qui devraient être "
"exécutés ensemble."

#: ../Doc/library/unittest.rst:47
msgid "test runner"
msgstr "lanceur de tests"

#: ../Doc/library/unittest.rst:44
msgid ""
"A :dfn:`test runner` is a component which orchestrates the execution of "
"tests and provides the outcome to the user.  The runner may use a graphical "
"interface, a textual interface, or return a special value to indicate the "
"results of executing the tests."
msgstr ""
"Un :dfn:`lanceur de tests` est un composant qui orchestre l'exécution des "
"tests et fournit le résultat pour l'utilisateur. Le lanceur peut utiliser "
"une interface graphique, une interface textuelle, ou renvoie une valeur "
"spéciale pour indiquer les résultats de l'exécution des tests."

#: ../Doc/library/unittest.rst:49
msgid ""
"The test case and test fixture concepts are supported through the :class:"
"`TestCase` and :class:`FunctionTestCase` classes; the former should be used "
"when creating new tests, and the latter can be used when integrating "
"existing test code with a :mod:`unittest`\\ -driven framework. When building "
"test fixtures using :class:`TestCase`, the :meth:`~TestCase.setUp` and :meth:"
"`~TestCase.tearDown` methods can be overridden to provide initialization and "
"cleanup for the fixture.  With :class:`FunctionTestCase`, existing functions "
"can be passed to the constructor for these purposes.  When the test is run, "
"the fixture initialization is run first; if it succeeds, the cleanup method "
"is run after the test has been executed, regardless of the outcome of the "
"test.  Each instance of the :class:`TestCase` will only be used to run a "
"single test method, so a new fixture is created for each test."
msgstr ""

#: ../Doc/library/unittest.rst:62
msgid ""
"Test suites are implemented by the :class:`TestSuite` class.  This class "
"allows individual tests and test suites to be aggregated; when the suite is "
"executed, all tests added directly to the suite and in \"child\" test suites "
"are run."
msgstr ""

#: ../Doc/library/unittest.rst:66
msgid ""
"A test runner is an object that provides a single method, :meth:`~TestRunner."
"run`, which accepts a :class:`TestCase` or :class:`TestSuite` object as a "
"parameter, and returns a result object.  The class :class:`TestResult` is "
"provided for use as the result object. :mod:`unittest` provides the :class:"
"`TextTestRunner` as an example test runner which reports test results on the "
"standard error stream by default.  Alternate runners can be implemented for "
"other environments (such as graphical environments) without any need to "
"derive from a specific class."
msgstr ""

#: ../Doc/library/unittest.rst:79
msgid "Module :mod:`doctest`"
msgstr "Module :mod:`doctest`"

#: ../Doc/library/unittest.rst:79
msgid "Another test-support module with a very different flavor."
msgstr "Un autre module de test adoptant une approche très différente."

#: ../Doc/library/unittest.rst:84
msgid ""
"`unittest2: A backport of new unittest features for Python 2.4-2.6 <https://"
"pypi.python.org/pypi/unittest2>`_"
msgstr ""

#: ../Doc/library/unittest.rst:82
msgid ""
"Many new features were added to unittest in Python 2.7, including test "
"discovery. unittest2 allows you to use these features with earlier versions "
"of Python."
msgstr ""

#: ../Doc/library/unittest.rst:88
msgid ""
"`Simple Smalltalk Testing: With Patterns <https://web.archive.org/"
"web/20150315073817/http://www.xprogramming.com/testfram.htm>`_"
msgstr ""
"`Simple Smalltalk Testing: With Patterns <https://web.archive.org/"
"web/20150315073817/http://www.xprogramming.com/testfram.htm>`_"

#: ../Doc/library/unittest.rst:87
msgid ""
"Kent Beck's original paper on testing frameworks using the pattern shared "
"by :mod:`unittest`."
msgstr ""
"Le papier originel de Kent Beck sur les *frameworks* de test utilisant le "
"modèle sur lequel s'appuie :mod:`unittest`."

#: ../Doc/library/unittest.rst:92
msgid ""
"`Nose <https://nose.readthedocs.org/en/latest/>`_ and `py.test <http://"
"pytest.org>`_"
msgstr ""

#: ../Doc/library/unittest.rst:91
msgid ""
"Third-party unittest frameworks with a lighter-weight syntax for writing "
"tests.  For example, ``assert func(10) == 42``."
msgstr ""
"Des *frameworks* tierces de tests unitaires avec une syntaxe allégée pour "
"l'écriture des tests. Par exemple, ``assert func(10) == 42``."

#: ../Doc/library/unittest.rst:96
msgid ""
"`The Python Testing Tools Taxonomy <https://wiki.python.org/moin/"
"PythonTestingToolsTaxonomy>`_"
msgstr ""
"`The Python Testing Tools Taxonomy <https://wiki.python.org/moin/"
"PythonTestingToolsTaxonomy>`_"

#: ../Doc/library/unittest.rst:95
msgid ""
"An extensive list of Python testing tools including functional testing "
"frameworks and mock object libraries."
msgstr ""
"Une liste étendue des outils de test pour Python comprenant des *frameworks* "
"de tests fonctionnels et des bibliothèques d'objets simulés (*mocks*)."

#: ../Doc/library/unittest.rst:99
msgid ""
"`Testing in Python Mailing List <http://lists.idyll.org/listinfo/testing-in-"
"python>`_"
msgstr ""
"`Testing in Python Mailing List <http://lists.idyll.org/listinfo/testing-in-"
"python>`_"

#: ../Doc/library/unittest.rst:99
msgid ""
"A special-interest-group for discussion of testing, and testing tools, in "
"Python."
msgstr "un groupe de discussion dédié aux tests, et outils de test, en Python."

#: ../Doc/library/unittest.rst:106
msgid "Basic example"
msgstr "Exemple basique"

#: ../Doc/library/unittest.rst:108
msgid ""
"The :mod:`unittest` module provides a rich set of tools for constructing and "
"running tests.  This section demonstrates that a small subset of the tools "
"suffice to meet the needs of most users."
msgstr ""
"Le module :mod:`unittest` fournit un riche ensemble d'outils pour construire "
"et lancer des tests. Cette section montre qu'une petite partie des outils "
"suffit pour satisfaire les besoins de la plupart des utilisateurs."

#: ../Doc/library/unittest.rst:112
msgid "Here is a short script to test three string methods::"
msgstr "Voici un court script pour tester trois méthodes de *string* ::"

#: ../Doc/library/unittest.rst:136
msgid ""
"A testcase is created by subclassing :class:`unittest.TestCase`.  The three "
"individual tests are defined with methods whose names start with the letters "
"``test``.  This naming convention informs the test runner about which "
"methods represent tests."
msgstr ""
"Un scénario de test est créé comme classe-fille de :class:`unittest."
"TestCase`. Les trois tests individuels sont définis par des méthodes dont "
"les noms commencent par les lettres ``test``. Cette convention de nommage "
"signale au lanceur de tests quelles méthodes sont des tests."

#: ../Doc/library/unittest.rst:141
msgid ""
"The crux of each test is a call to :meth:`~TestCase.assertEqual` to check "
"for an expected result; :meth:`~TestCase.assertTrue` or :meth:`~TestCase."
"assertFalse` to verify a condition; or :meth:`~TestCase.assertRaises` to "
"verify that a specific exception gets raised.  These methods are used "
"instead of the :keyword:`assert` statement so the test runner can accumulate "
"all test results and produce a report."
msgstr ""
"Le cœur de chaque test est un appel à :meth:`~TestCase.assertEqual` pour "
"vérifier un résultat attendu ; :meth:`~TestCase.assertTrue` ou :meth:"
"`~TestCase.assertFalse` pour vérifier une condition ; ou :meth:`~TestCase."
"assertRaises` pour vérifier qu'une exception particulière est levée. Ces "
"méthodes sont utilisées à la place du mot-clé :keyword:`assert`  pour que le "
"lanceur de tests puisse récupérer les résultats de tous les tests et "
"produire un rapport."

#: ../Doc/library/unittest.rst:148
msgid ""
"The :meth:`~TestCase.setUp` and :meth:`~TestCase.tearDown` methods allow you "
"to define instructions that will be executed before and after each test "
"method. They are covered in more detail in the section :ref:`organizing-"
"tests`."
msgstr ""
"Les méthodes :meth:`~TestCase.setUp` et :meth:`~TestCase.tearDown` vous "
"autorisent à définir des instructions qui seront exécutées avant et après "
"chaque méthode test. Elles sont davantage détaillées dans la section :ref:"
"`organizing-tests`."

#: ../Doc/library/unittest.rst:152
msgid ""
"The final block shows a simple way to run the tests. :func:`unittest.main` "
"provides a command-line interface to the test script.  When run from the "
"command line, the above script produces an output that looks like this::"
msgstr ""
"Le bloc final montre une manière simple de lancer les tests. :func:`unittest."
"main` fournit une interface en ligne de commande pour le script de test. "
"Lorsqu'il est lancé en ligne de commande, le script ci-dessus produit une "
"sortie qui ressemble à ceci ::"

#: ../Doc/library/unittest.rst:162
msgid ""
"Instead of :func:`unittest.main`, there are other ways to run the tests with "
"a finer level of control, less terse output, and no requirement to be run "
"from the command line.  For example, the last two lines may be replaced "
"with::"
msgstr ""

#: ../Doc/library/unittest.rst:169
msgid ""
"Running the revised script from the interpreter or another script produces "
"the following output::"
msgstr ""

#: ../Doc/library/unittest.rst:181
msgid ""
"The above examples show the most commonly used :mod:`unittest` features "
"which are sufficient to meet many everyday testing needs.  The remainder of "
"the documentation explores the full feature set from first principles."
msgstr ""
"Les exemples ci-dessus montrent les fonctionnalités d':mod:`unittest` les "
"plus communément utilisées et qui sont suffisantes pour couvrir les besoins "
"courants en matière de test. Le reste de la documentation explore l'ensemble "
"complet des fonctionnalités depuis les premiers principes."

#: ../Doc/library/unittest.rst:189
msgid "Command-Line Interface"
msgstr "Interface en ligne de commande"

#: ../Doc/library/unittest.rst:191
msgid ""
"The unittest module can be used from the command line to run tests from "
"modules, classes or even individual test methods::"
msgstr ""
"Le module *unittest* est utilisable depuis la ligne de commande pour "
"exécuter des tests à partir de modules, de classes ou même de méthodes de "
"test individuelles  ::"

#: ../Doc/library/unittest.rst:198
msgid ""
"You can pass in a list with any combination of module names, and fully "
"qualified class or method names."
msgstr ""
"La commande accepte en argument une liste de n'importe quelle combinaison de "
"noms de modules et de noms de classes ou de méthodes entièrement qualifiés."

#: ../Doc/library/unittest.rst:201
msgid ""
"You can run tests with more detail (higher verbosity) by passing in the -v "
"flag::"
msgstr ""
"Pour obtenir plus de détails lors de l'exécution utilisez l'option `-v` "
"(plus de verbosité) ::"

#: ../Doc/library/unittest.rst:205
msgid "For a list of all the command-line options::"
msgstr ""
"Pour afficher la liste de toutes les options de la commande utilisez "
"l'option `-h` ::"

#: ../Doc/library/unittest.rst:209
msgid ""
"In earlier versions it was only possible to run individual test methods and "
"not modules or classes."
msgstr ""
"Dans les versions antérieures, il était seulement possible d'exécuter des "
"méthodes de test individuelles et non des modules ou des classes."

#: ../Doc/library/unittest.rst:215
msgid "Command-line options"
msgstr "Options de la ligne de commande"

#: ../Doc/library/unittest.rst:217
msgid ":program:`unittest` supports these command-line options:"
msgstr "Le programme : `unittest` gère ces options de la ligne de commande :"

#: ../Doc/library/unittest.rst:223
msgid ""
"The standard output and standard error streams are buffered during the test "
"run. Output during a passing test is discarded. Output is echoed normally on "
"test fail or error and is added to the failure messages."
msgstr ""
"Les flux de sortie et d'erreur standards sont mis en mémoire tampon pendant "
"l'exécution des tests. L'affichage produit par un test réussi n'est pas pris "
"en compte. Les sorties d'affichages d'un test en échec ou en erreur sont "
"conservés et  ajoutés aux messages d'erreur."

#: ../Doc/library/unittest.rst:229
msgid ""
":kbd:`Control-C` during the test run waits for the current test to end and "
"then reports all the results so far. A second :kbd:`Control-C` raises the "
"normal :exc:`KeyboardInterrupt` exception."
msgstr ""
"Utiliser :kbd:`Control-C` pendant l'exécution des tests attend que le test "
"en cours se termine, puis affiche tous les résultats obtenus jusqu'ici. Une "
"seconde utilisation de :kbd:`Control-C` provoque l'exception normale :exc:"
"`KeyboardInterrupt`."

#: ../Doc/library/unittest.rst:233
msgid ""
"See `Signal Handling`_ for the functions that provide this functionality."
msgstr ""
"Voir `Signal Handling`_ pour les fonctions qui utilisent cette "
"fonctionnalité."

#: ../Doc/library/unittest.rst:237
msgid "Stop the test run on the first error or failure."
msgstr "Arrête l'exécution des tests lors du premier cas d'erreur ou d'échec."

#: ../Doc/library/unittest.rst:239
msgid "The command-line options ``-b``, ``-c`` and ``-f`` were added."
msgstr ""
"Les options de ligne de commande ``-b``, ``-c`` et ``-f`` ont été ajoutées."

#: ../Doc/library/unittest.rst:242
msgid ""
"The command line can also be used for test discovery, for running all of the "
"tests in a project or just a subset."
msgstr ""
"La ligne de commande peut également être utilisée pour découvrir les tests, "
"pour exécuter tous les tests dans un projet ou juste un sous-ensemble."

#: ../Doc/library/unittest.rst:249
msgid "Test Discovery"
msgstr "Découverte des tests"

#: ../Doc/library/unittest.rst:253
msgid ""
"Unittest supports simple test discovery. In order to be compatible with test "
"discovery, all of the test files must be :ref:`modules <tut-modules>` or :"
"ref:`packages <tut-packages>` importable from the top-level directory of the "
"project (this means that their filenames must be valid :ref:`identifiers "
"<identifiers>`)."
msgstr ""

#: ../Doc/library/unittest.rst:259
msgid ""
"Test discovery is implemented in :meth:`TestLoader.discover`, but can also "
"be used from the command line. The basic command-line usage is::"
msgstr ""
"La découverte de tests est implémentée dans :meth:`TestLoader.discover`, "
"mais peut également être utilisée depuis la ligne de commande. Par exemple "
" ::"

#: ../Doc/library/unittest.rst:265
msgid "The ``discover`` sub-command has the following options:"
msgstr "La sous-commande ``discover`` a les options suivantes  ::"

#: ../Doc/library/unittest.rst:271
msgid "Verbose output"
msgstr "Affichage plus détaillé"

#: ../Doc/library/unittest.rst:275
msgid "Directory to start discovery (``.`` default)"
msgstr "Répertoire racine pour démarrer la découverte (``.`` par défaut)."

#: ../Doc/library/unittest.rst:279
msgid "Pattern to match test files (``test*.py`` default)"
msgstr "Motif de détection des fichiers de test (``test*.py`` par défaut)"

#: ../Doc/library/unittest.rst:283
msgid "Top level directory of project (defaults to start directory)"
msgstr "Dossier du premier niveau du projet (Par défaut le dossier de départ)"

#: ../Doc/library/unittest.rst:285
msgid ""
"The :option:`-s`, :option:`-p`, and :option:`-t` options can be passed in as "
"positional arguments in that order. The following two command lines are "
"equivalent::"
msgstr ""
"Les options :option:`-s`, :option:`-p` et :option:`-t` peuvent être passées "
"en arguments positionnels dans cet ordre. Les deux lignes de commande "
"suivantes sont équivalentes  ::"

#: ../Doc/library/unittest.rst:292
msgid ""
"As well as being a path it is possible to pass a package name, for example "
"``myproject.subpackage.test``, as the start directory. The package name you "
"supply will then be imported and its location on the filesystem will be used "
"as the start directory."
msgstr ""
"Il est aussi possible de passer un nom de paquet plutôt qu'un chemin, par "
"exemple ``monprojet.souspaquet.test``, comme répertoire racine. Le nom du "
"paquet fourni est alors importé et son emplacement sur le système de "
"fichiers est utilisé comme répertoire racine."

#: ../Doc/library/unittest.rst:299
msgid ""
"Test discovery loads tests by importing them. Once test discovery has found "
"all the test files from the start directory you specify it turns the paths "
"into package names to import. For example :file:`foo/bar/baz.py` will be "
"imported as ``foo.bar.baz``."
msgstr ""
"Le mécanisme de découverte charge les tests en les important. Une fois que "
"le système a trouvé tous les fichiers de tests du répertoire de démarrage "
"spécifié, il transforme les chemins en noms de paquets à importer. Par "
"exemple :file:`truc/bidule/machin.py` est importé sous ``truc.bidule."
"machin``."

#: ../Doc/library/unittest.rst:304
msgid ""
"If you have a package installed globally and attempt test discovery on a "
"different copy of the package then the import *could* happen from the wrong "
"place. If this happens test discovery will warn you and exit."
msgstr ""
"Si un paquet est installé globalement et que le mécanisme de découverte de "
"tests est effectué sur une copie différente du paquet, l'importation *peut* "
"se produire à partir du mauvais endroit. Si cela arrive, le système émet un "
"avertissement et se termine."

#: ../Doc/library/unittest.rst:308
msgid ""
"If you supply the start directory as a package name rather than a path to a "
"directory then discover assumes that whichever location it imports from is "
"the location you intended, so you will not get the warning."
msgstr ""
"Si vous donnez le répertoire racine sous la forme d'un nom de paquet plutôt "
"que d'un chemin d'accès à un répertoire, alors Python suppose que "
"l'emplacement à partir duquel il importe est l'emplacement que vous voulez, "
"vous ne verrez donc pas l'avertissement."

#: ../Doc/library/unittest.rst:313
msgid ""
"Test modules and packages can customize test loading and discovery by "
"through the `load_tests protocol`_."
msgstr ""
"Les modules de test et les paquets peuvent adapter le chargement et la "
"découverte des tests en utilisant le protocole `load_tests protocol`_."

#: ../Doc/library/unittest.rst:320
msgid "Organizing test code"
msgstr "Organiser le code de test"

#: ../Doc/library/unittest.rst:322
msgid ""
"The basic building blocks of unit testing are :dfn:`test cases` --- single "
"scenarios that must be set up and checked for correctness.  In :mod:"
"`unittest`, test cases are represented by instances of :mod:`unittest`'s :"
"class:`TestCase` class. To make your own test cases you must write "
"subclasses of :class:`TestCase`, or use :class:`FunctionTestCase`."
msgstr ""

#: ../Doc/library/unittest.rst:328
msgid ""
"An instance of a :class:`TestCase`\\ -derived class is an object that can "
"completely run a single test method, together with optional set-up and tidy-"
"up code."
msgstr ""

#: ../Doc/library/unittest.rst:332
msgid ""
"The testing code of a :class:`TestCase` instance should be entirely self "
"contained, such that it can be run either in isolation or in arbitrary "
"combination with any number of other test cases."
msgstr ""
"Le code de test d'une instance de :class:`TestCase` doit être entièrement "
"autonome, de sorte qu'il puisse être exécuté soit de manière isolée, soit en "
"combinaison arbitraire avec un nombre quelconque d'autres scénarios de test."

#: ../Doc/library/unittest.rst:336
msgid ""
"The simplest :class:`TestCase` subclass will simply override the :meth:"
"`~TestCase.runTest` method in order to perform specific testing code::"
msgstr ""

#: ../Doc/library/unittest.rst:346
msgid ""
"Note that in order to test something, we use one of the :meth:`assert\\*` "
"methods provided by the :class:`TestCase` base class.  If the test fails, an "
"exception will be raised, and :mod:`unittest` will identify the test case as "
"a :dfn:`failure`.  Any other exceptions will be treated as :dfn:`errors`. "
"This helps you identify where the problem is: :dfn:`failures` are caused by "
"incorrect results - a 5 where you expected a 6. :dfn:`Errors` are caused by "
"incorrect code - e.g., a :exc:`TypeError` caused by an incorrect function "
"call."
msgstr ""

#: ../Doc/library/unittest.rst:354
msgid ""
"The way to run a test case will be described later.  For now, note that to "
"construct an instance of such a test case, we call its constructor without "
"arguments::"
msgstr ""

#: ../Doc/library/unittest.rst:360
msgid ""
"Now, such test cases can be numerous, and their set-up can be repetitive.  "
"In the above case, constructing a :class:`Widget` in each of 100 Widget test "
"case subclasses would mean unsightly duplication."
msgstr ""

#: ../Doc/library/unittest.rst:364
msgid ""
"Luckily, we can factor out such set-up code by implementing a method called :"
"meth:`~TestCase.setUp`, which the testing framework will automatically call "
"for us when we run the test::"
msgstr ""

#: ../Doc/library/unittest.rst:385
msgid ""
"If the :meth:`~TestCase.setUp` method raises an exception while the test is "
"running, the framework will consider the test to have suffered an error, and "
"the :meth:`~TestCase.runTest` method will not be executed."
msgstr ""

#: ../Doc/library/unittest.rst:389
msgid ""
"Similarly, we can provide a :meth:`~TestCase.tearDown` method that tidies up "
"after the :meth:`~TestCase.runTest` method has been run::"
msgstr ""

#: ../Doc/library/unittest.rst:402
msgid ""
"If :meth:`~TestCase.setUp` succeeded, the :meth:`~TestCase.tearDown` method "
"will be run whether :meth:`~TestCase.runTest` succeeded or not."
msgstr ""

#: ../Doc/library/unittest.rst:405
msgid ""
"Such a working environment for the testing code is called a :dfn:`fixture`."
msgstr ""

#: ../Doc/library/unittest.rst:407
msgid ""
"Often, many small test cases will use the same fixture.  In this case, we "
"would end up subclassing :class:`SimpleWidgetTestCase` into many small one-"
"method classes such as :class:`DefaultWidgetSizeTestCase`.  This is time-"
"consuming and discouraging, so in the same vein as JUnit, :mod:`unittest` "
"provides a simpler mechanism::"
msgstr ""

#: ../Doc/library/unittest.rst:432
msgid ""
"Here we have not provided a :meth:`~TestCase.runTest` method, but have "
"instead provided two different test methods.  Class instances will now each "
"run one of the :meth:`test_\\*` methods, with ``self.widget`` created and "
"destroyed separately for each instance.  When creating an instance we must "
"specify the test method it is to run.  We do this by passing the method name "
"in the constructor::"
msgstr ""

#: ../Doc/library/unittest.rst:442
msgid ""
"Test case instances are grouped together according to the features they "
"test. :mod:`unittest` provides a mechanism for this: the :dfn:`test suite`, "
"represented by :mod:`unittest`'s :class:`TestSuite` class::"
msgstr ""

#: ../Doc/library/unittest.rst:450
msgid ""
"For the ease of running tests, as we will see later, it is a good idea to "
"provide in each test module a callable object that returns a pre-built test "
"suite::"
msgstr ""

#: ../Doc/library/unittest.rst:460
msgid "or even::"
msgstr ""

#: ../Doc/library/unittest.rst:467
msgid ""
"Since it is a common pattern to create a :class:`TestCase` subclass with "
"many similarly named test functions, :mod:`unittest` provides a :class:"
"`TestLoader` class that can be used to automate the process of creating a "
"test suite and populating it with individual tests. For example, ::"
msgstr ""

#: ../Doc/library/unittest.rst:474
msgid ""
"will create a test suite that will run ``WidgetTestCase."
"test_default_size()`` and ``WidgetTestCase.test_resize``. :class:"
"`TestLoader` uses the ``'test'`` method name prefix to identify test methods "
"automatically."
msgstr ""

#: ../Doc/library/unittest.rst:478
msgid ""
"Note that the order in which the various test cases will be run is "
"determined by sorting the test function names with respect to the built-in "
"ordering for strings."
msgstr ""

#: ../Doc/library/unittest.rst:482
msgid ""
"Often it is desirable to group suites of test cases together, so as to run "
"tests for the whole system at once.  This is easy, since :class:`TestSuite` "
"instances can be added to a :class:`TestSuite` just as :class:`TestCase` "
"instances can be added to a :class:`TestSuite`::"
msgstr ""

#: ../Doc/library/unittest.rst:491
msgid ""
"You can place the definitions of test cases and test suites in the same "
"modules as the code they are to test (such as :file:`widget.py`), but there "
"are several advantages to placing the test code in a separate module, such "
"as :file:`test_widget.py`:"
msgstr ""
"Vous pouvez placer les définitions des scénarios de test et des suites de "
"test dans le même module que le code à tester (tel que :file:`composant."
"py`), mais il y a plusieurs avantages à placer le code de test dans un "
"module séparé, tel que :file:`test_composant.py` :"

#: ../Doc/library/unittest.rst:496
msgid "The test module can be run standalone from the command line."
msgstr ""
"Le module de test peut être exécuté indépendamment depuis la ligne de "
"commande."

#: ../Doc/library/unittest.rst:498
msgid "The test code can more easily be separated from shipped code."
msgstr "Le code de test est plus facilement séparable du code livré."

#: ../Doc/library/unittest.rst:500
msgid ""
"There is less temptation to change test code to fit the code it tests "
"without a good reason."
msgstr ""
"La tentation est moins grande de changer le code de test pour l'adapter au "
"code qu'il teste sans avoir une bonne raison."

#: ../Doc/library/unittest.rst:503
msgid ""
"Test code should be modified much less frequently than the code it tests."
msgstr ""
"Le code de test doit être modifié beaucoup moins souvent que le code qu'il "
"teste."

#: ../Doc/library/unittest.rst:505
msgid "Tested code can be refactored more easily."
msgstr "Le code testé peut être réusiné plus facilement."

#: ../Doc/library/unittest.rst:507
msgid ""
"Tests for modules written in C must be in separate modules anyway, so why "
"not be consistent?"
msgstr ""
"Les tests pour les modules écrits en C doivent de toute façon être dans des "
"modules séparés, alors pourquoi ne pas être cohérent ?"

#: ../Doc/library/unittest.rst:510
msgid ""
"If the testing strategy changes, there is no need to change the source code."
msgstr ""
"Si la stratégie de test change, il n'est pas nécessaire de changer le code "
"source."

#: ../Doc/library/unittest.rst:516
msgid "Re-using old test code"
msgstr "Réutilisation d'ancien code de test"

#: ../Doc/library/unittest.rst:518
msgid ""
"Some users will find that they have existing test code that they would like "
"to run from :mod:`unittest`, without converting every old test function to "
"a :class:`TestCase` subclass."
msgstr ""
"Certains utilisateurs constatent qu'ils ont du code de test existant qu'ils "
"souhaitent exécuter à partir de :mod:`unittest`, sans convertir chaque "
"ancienne fonction de test en une sous-classe de :class:`TestCase`."

#: ../Doc/library/unittest.rst:522
msgid ""
"For this reason, :mod:`unittest` provides a :class:`FunctionTestCase` class. "
"This subclass of :class:`TestCase` can be used to wrap an existing test "
"function.  Set-up and tear-down functions can also be provided."
msgstr ""
"Pour cette raison, :mod:`unittest` fournit une classe :class:"
"`FunctionTestCase`. Cette sous-classe de :class:`TestCase` peut être "
"utilisée pour encapsuler une fonction de test existante. Des fonctions de "
"mise en place (*setUp*) et de démantèlement (*tearDown*) peuvent également "
"être fournies."

#: ../Doc/library/unittest.rst:526
msgid "Given the following test function::"
msgstr "Étant donnée la fonction de test suivante  ::"

#: ../Doc/library/unittest.rst:533
msgid "one can create an equivalent test case instance as follows::"
msgstr ""

#: ../Doc/library/unittest.rst:537
msgid ""
"If there are additional set-up and tear-down methods that should be called "
"as part of the test case's operation, they can also be provided like so::"
msgstr ""

#: ../Doc/library/unittest.rst:544
msgid ""
"To make migrating existing test suites easier, :mod:`unittest` supports "
"tests raising :exc:`AssertionError` to indicate test failure. However, it is "
"recommended that you use the explicit :meth:`TestCase.fail\\*` and :meth:"
"`TestCase.assert\\*` methods instead, as future versions of :mod:`unittest` "
"may treat :exc:`AssertionError` differently."
msgstr ""

#: ../Doc/library/unittest.rst:552
msgid ""
"Even though :class:`FunctionTestCase` can be used to quickly convert an "
"existing test base over to a :mod:`unittest`\\ -based system, this approach "
"is not recommended.  Taking the time to set up proper :class:`TestCase` "
"subclasses will make future test refactorings infinitely easier."
msgstr ""
"Même si  la classe :class:`FunctionTestCase` peut être utilisée pour "
"convertir rapidement une base de test existante vers un système basé sur :"
"mod:`unittest`, cette approche n'est pas recommandée.  Prendre le temps de "
"bien configurer les sous-classes de :class:`TestCase` simplifiera "
"considérablement les futurs réusinages des tests."

#: ../Doc/library/unittest.rst:557
msgid ""
"In some cases, the existing tests may have been written using the :mod:"
"`doctest` module.  If so, :mod:`doctest` provides a :class:`DocTestSuite` "
"class that can automatically build :class:`unittest.TestSuite` instances "
"from the existing :mod:`doctest`\\ -based tests."
msgstr ""
"Dans certains cas, les tests déjà existants ont pu être écrits avec le "
"module :mod:`doctest`.  Dans ce cas, :mod:`doctest` fournit une classe :"
"class:`DocTestSuite` qui peut construire automatiquement des instances de la "
"classe :class:`unittest.TestSuite` depuis des tests basés sur le module :mod:"
"`doctest`."

#: ../Doc/library/unittest.rst:566
msgid "Skipping tests and expected failures"
msgstr "Ignorer des tests et des erreurs prévisibles"

#: ../Doc/library/unittest.rst:570
msgid ""
"Unittest supports skipping individual test methods and even whole classes of "
"tests.  In addition, it supports marking a test as an \"expected failure,\" "
"a test that is broken and will fail, but shouldn't be counted as a failure "
"on a :class:`TestResult`."
msgstr ""
"*Unittest* permet d'ignorer des méthodes de test individuelles et même des "
"classes entières de tests. De plus, il prend en charge le marquage d'un test "
"comme étant une \"erreur prévue\". Un test qui est cassé et qui échoue, mais "
"qui ne doit pas être considéré comme un échec dans la classe :class:"
"`TestResult`."

#: ../Doc/library/unittest.rst:575
msgid ""
"Skipping a test is simply a matter of using the :func:`skip` :term:"
"`decorator` or one of its conditional variants."
msgstr ""
"Ignorer un test consiste à utiliser le :term:`décorateur <decorator>` :func:"
"`skip`  ou une de ses variantes conditionnelles."

#: ../Doc/library/unittest.rst:578
msgid "Basic skipping looks like this::"
msgstr "Un exemple de tests à ignorer  ::"

#: ../Doc/library/unittest.rst:597
msgid "This is the output of running the example above in verbose mode::"
msgstr ""
"Ceci est le résultat de l'exécution de l'exemple ci-dessus en mode verbeux "
" ::"

#: ../Doc/library/unittest.rst:608
msgid "Classes can be skipped just like methods::"
msgstr "Les classes peuvent être ignorées tout comme les méthodes  ::"

#: ../Doc/library/unittest.rst:615
msgid ""
":meth:`TestCase.setUp` can also skip the test.  This is useful when a "
"resource that needs to be set up is not available."
msgstr ""
"La méthode :meth:`TestCase.setUp` permet également d'ignorer le test.  Ceci "
"est utile lorsqu'une ressource qui doit être configurée n'est pas disponible."

#: ../Doc/library/unittest.rst:618
msgid "Expected failures use the :func:`expectedFailure` decorator. ::"
msgstr ""
"Les erreurs prévisibles utilisent le décorateur :func:`expectedFailure`  ::"

#: ../Doc/library/unittest.rst:625
msgid ""
"It's easy to roll your own skipping decorators by making a decorator that "
"calls :func:`skip` on the test when it wants it to be skipped.  This "
"decorator skips the test unless the passed object has a certain attribute::"
msgstr ""
"Il est facile de faire ses propres décorateurs en créant un décorateur qui "
"appelle :func:`skip` sur le test que vous voulez ignorer. Par exemple, ce "
"décorateur ignore le test à moins que l'objet passé ne possède un certain "
"attribut  ::"

#: ../Doc/library/unittest.rst:634
msgid "The following decorators implement test skipping and expected failures:"
msgstr ""
"Les décorateurs suivants implémentent le système d'omission des tests et les "
"erreurs prévisibles  ::"

#: ../Doc/library/unittest.rst:638
msgid ""
"Unconditionally skip the decorated test.  *reason* should describe why the "
"test is being skipped."
msgstr ""
"Ignore sans condition le test décoré.  *La raison* doit décrire la raison "
"pour laquelle le test est omis."

#: ../Doc/library/unittest.rst:643
msgid "Skip the decorated test if *condition* is true."
msgstr "Ignore le test décoré si la *condition* est vraie."

#: ../Doc/library/unittest.rst:647
msgid "Skip the decorated test unless *condition* is true."
msgstr "Ignore le test décoré sauf si la *condition* est vraie."

#: ../Doc/library/unittest.rst:651
msgid ""
"Mark the test as an expected failure.  If the test fails when run, the test "
"is not counted as a failure."
msgstr ""

#: ../Doc/library/unittest.rst:656
msgid "This exception is raised to skip a test."
msgstr "Cette exception est levée pour ignorer un test."

#: ../Doc/library/unittest.rst:658
msgid ""
"Usually you can use :meth:`TestCase.skipTest` or one of the skipping "
"decorators instead of raising this directly."
msgstr ""
"Habituellement, on utilise :meth:`TestCase.skipTest` ou l'un des décorateurs "
"d'omission au lieu de le lever une exception directement."

#: ../Doc/library/unittest.rst:661
msgid ""
"Skipped tests will not have :meth:`setUp` or :meth:`tearDown` run around "
"them. Skipped classes will not have :meth:`setUpClass` or :meth:"
"`tearDownClass` run."
msgstr ""

#: ../Doc/library/unittest.rst:668
msgid "Classes and functions"
msgstr "Classes et fonctions"

#: ../Doc/library/unittest.rst:670
msgid "This section describes in depth the API of :mod:`unittest`."
msgstr "Cette section décrit en détail l'API de :mod:`unittest`."

#: ../Doc/library/unittest.rst:676
msgid "Test cases"
msgstr "Scénarios de tests"

#: ../Doc/library/unittest.rst:680
msgid ""
"Instances of the :class:`TestCase` class represent the smallest testable "
"units in the :mod:`unittest` universe.  This class is intended to be used as "
"a base class, with specific tests being implemented by concrete subclasses.  "
"This class implements the interface needed by the test runner to allow it to "
"drive the test, and methods that the test code can use to check for and "
"report various kinds of failure."
msgstr ""

#: ../Doc/library/unittest.rst:687
msgid ""
"Each instance of :class:`TestCase` will run a single test method: the method "
"named *methodName*.  If you remember, we had an earlier example that went "
"something like this::"
msgstr ""

#: ../Doc/library/unittest.rst:697
msgid ""
"Here, we create two instances of :class:`WidgetTestCase`, each of which runs "
"a single test."
msgstr ""

#: ../Doc/library/unittest.rst:700
msgid "*methodName* defaults to :meth:`runTest`."
msgstr ""

#: ../Doc/library/unittest.rst:702
msgid ""
":class:`TestCase` instances provide three groups of methods: one group used "
"to run the test, another used by the test implementation to check conditions "
"and report failures, and some inquiry methods allowing information about the "
"test itself to be gathered."
msgstr ""
"Les instances de la classe :class:`TestCase` fournissent trois groupes de "
"méthodes : un groupe utilisé pour exécuter le test, un autre utilisé par "
"l'implémentation du test pour vérifier les conditions et signaler les "
"échecs, et quelques méthodes de recherche permettant de recueillir des "
"informations sur le test lui-même."

#: ../Doc/library/unittest.rst:707
msgid "Methods in the first group (running the test) are:"
msgstr "Les méthodes du premier groupe (exécution du test) sont :"

#: ../Doc/library/unittest.rst:712
msgid ""
"Method called to prepare the test fixture.  This is called immediately "
"before calling the test method; other than :exc:`AssertionError` or :exc:"
"`SkipTest`, any exception raised by this method will be considered an error "
"rather than a test failure. The default implementation does nothing."
msgstr ""
"Méthode appelée pour réaliser la mise en place du test. Elle est exécutée "
"immédiatement avant l'appel de la méthode de test ; à l'exception de :exc:"
"`AssertionError` ou :exc:`SkipTest`, toute exception levée par cette méthode "
"est considérée comme une erreur et non pas comme un échec du test. "
"L'implémentation par défaut ne fait rien."

#: ../Doc/library/unittest.rst:720
msgid ""
"Method called immediately after the test method has been called and the "
"result recorded.  This is called even if the test method raised an "
"exception, so the implementation in subclasses may need to be particularly "
"careful about checking internal state.  Any exception, other than :exc:"
"`AssertionError` or :exc:`SkipTest`, raised by this method will be "
"considered an additional error rather than a test failure (thus increasing "
"the total number of reported errors). This method will only be called if "
"the :meth:`setUp` succeeds, regardless of the outcome of the test method. "
"The default implementation does nothing."
msgstr ""
"Méthode appelée immédiatement après l'appel de la méthode de test et "
"l'enregistrement du résultat.  Elle est appelée même si la méthode de test a "
"levé une exception. De fait, l'implémentation d'un sous-classes doit être "
"fait avec précaution  si vous vérifiez l'état interne de la classe. Toute "
"exception, autre que :exc:`AssertionError` ou :exc:`SkipTest`, levée par "
"cette méthode est considérée comme une erreur supplémentaire plutôt que "
"comme un échec du test (augmentant ainsi le nombre total des erreurs "
"signalées). Cette méthode est appelée uniquement si l'exécution de :meth:"
"`setUp` est réussie quel que soit le résultat de la méthode de test. "
"L'implémentation par défaut ne fait rien."

#: ../Doc/library/unittest.rst:733
msgid ""
"A class method called before tests in an individual class run. "
"``setUpClass`` is called with the class as the only argument and must be "
"decorated as a :func:`classmethod`::"
msgstr ""

#: ../Doc/library/unittest.rst:741 ../Doc/library/unittest.rst:756
msgid "See `Class and Module Fixtures`_ for more details."
msgstr "Voir `Class and Module Fixtures`_ pour plus de détails."

#: ../Doc/library/unittest.rst:748
msgid ""
"A class method called after tests in an individual class have run. "
"``tearDownClass`` is called with the class as the only argument and must be "
"decorated as a :meth:`classmethod`::"
msgstr ""
"Méthode de classe appelée après l'exécution des tests de la classe en "
"question. ``tearDownClass`` est appelée avec la classe comme seul argument "
"et doit être décorée comme une :meth:`classmethod`  ::"

#: ../Doc/library/unittest.rst:763
msgid ""
"Run the test, collecting the result into the test result object passed as "
"*result*.  If *result* is omitted or ``None``, a temporary result object is "
"created (by calling the :meth:`defaultTestResult` method) and used. The "
"result object is not returned to :meth:`run`'s caller."
msgstr ""

#: ../Doc/library/unittest.rst:768
msgid ""
"The same effect may be had by simply calling the :class:`TestCase` instance."
msgstr ""
"Le même effet peut être obtenu en appelant simplement l'instance :class:"
"`TestCase`."

#: ../Doc/library/unittest.rst:774
msgid ""
"Calling this during a test method or :meth:`setUp` skips the current test.  "
"See :ref:`unittest-skipping` for more information."
msgstr ""
"Appeler cette fonction pendant l'exécution d'une méthode de test ou de :meth:"
"`setUp` permet d'ignorer le test en cours.  Voir :ref:`unittest-skipping` "
"pour plus d'informations."

#: ../Doc/library/unittest.rst:782
msgid ""
"Run the test without collecting the result.  This allows exceptions raised "
"by the test to be propagated to the caller, and can be used to support "
"running tests under a debugger."
msgstr ""
"Lance le test sans collecter le résultat.  Ceci permet aux exceptions levées "
"par le test d'être propagées à l'appelant, et donc peut être utilisé pour "
"exécuter des tests sous un débogueur."

#: ../Doc/library/unittest.rst:788
msgid ""
"The :class:`TestCase` class provides several assert methods to check for and "
"report failures.  The following table lists the most commonly used methods "
"(see the tables below for more assert methods):"
msgstr ""
"La classe :class:`TestCase` fournit plusieurs méthodes d'assertion pour "
"vérifier et signaler les échecs.  Le tableau suivant énumère les méthodes "
"les plus couramment utilisées (voir les tableaux ci-dessous pour plus de "
"méthodes d'assertion) :"

#: ../Doc/library/unittest.rst:793 ../Doc/library/unittest.rst:908
#: ../Doc/library/unittest.rst:970 ../Doc/library/unittest.rst:1113
msgid "Method"
msgstr "Méthode"

#: ../Doc/library/unittest.rst:793 ../Doc/library/unittest.rst:908
#: ../Doc/library/unittest.rst:970
msgid "Checks that"
msgstr "Vérifie que"

#: ../Doc/library/unittest.rst:793 ../Doc/library/unittest.rst:908
#: ../Doc/library/unittest.rst:970 ../Doc/library/unittest.rst:1113
msgid "New in"
msgstr "Disponible en"

#: ../Doc/library/unittest.rst:795
msgid ":meth:`assertEqual(a, b) <TestCase.assertEqual>`"
msgstr ":meth:`assertEqual(a, b) <TestCase.assertEqual>`"

#: ../Doc/library/unittest.rst:795
msgid "``a == b``"
msgstr "``a == b``"

#: ../Doc/library/unittest.rst:798
msgid ":meth:`assertNotEqual(a, b) <TestCase.assertNotEqual>`"
msgstr ":meth:`assertNotEqual(a, b) <TestCase.assertNotEqual>`"

#: ../Doc/library/unittest.rst:798
msgid "``a != b``"
msgstr "``a != b``"

#: ../Doc/library/unittest.rst:801
msgid ":meth:`assertTrue(x) <TestCase.assertTrue>`"
msgstr ":meth:`assertTrue(x) <TestCase.assertTrue>`"

#: ../Doc/library/unittest.rst:801
msgid "``bool(x) is True``"
msgstr "``bool(x) is True``"

#: ../Doc/library/unittest.rst:804
msgid ":meth:`assertFalse(x) <TestCase.assertFalse>`"
msgstr ":meth:`assertFalse(x) <TestCase.assertFalse>`"

#: ../Doc/library/unittest.rst:804
msgid "``bool(x) is False``"
msgstr "``bool(x) is False``"

#: ../Doc/library/unittest.rst:807
msgid ":meth:`assertIs(a, b) <TestCase.assertIs>`"
msgstr ":meth:`assertIs(a, b) <TestCase.assertIs>`"

#: ../Doc/library/unittest.rst:807
msgid "``a is b``"
msgstr "``a is b``"

#: ../Doc/library/unittest.rst:807 ../Doc/library/unittest.rst:810
#: ../Doc/library/unittest.rst:813 ../Doc/library/unittest.rst:816
#: ../Doc/library/unittest.rst:819 ../Doc/library/unittest.rst:822
#: ../Doc/library/unittest.rst:825 ../Doc/library/unittest.rst:828
#: ../Doc/library/unittest.rst:913 ../Doc/library/unittest.rst:978
#: ../Doc/library/unittest.rst:981 ../Doc/library/unittest.rst:984
#: ../Doc/library/unittest.rst:987 ../Doc/library/unittest.rst:990
#: ../Doc/library/unittest.rst:993 ../Doc/library/unittest.rst:996
#: ../Doc/library/unittest.rst:999 ../Doc/library/unittest.rst:1115
#: ../Doc/library/unittest.rst:1118 ../Doc/library/unittest.rst:1121
#: ../Doc/library/unittest.rst:1124 ../Doc/library/unittest.rst:1127
#: ../Doc/library/unittest.rst:1130
msgid "2.7"
msgstr "2.7"

#: ../Doc/library/unittest.rst:810
msgid ":meth:`assertIsNot(a, b) <TestCase.assertIsNot>`"
msgstr ":meth:`assertIsNot(a, b) <TestCase.assertIsNot>`"

#: ../Doc/library/unittest.rst:810
msgid "``a is not b``"
msgstr "``a is not b``"

#: ../Doc/library/unittest.rst:813
msgid ":meth:`assertIsNone(x) <TestCase.assertIsNone>`"
msgstr ":meth:`assertIsNone(x) <TestCase.assertIsNone>`"

#: ../Doc/library/unittest.rst:813
msgid "``x is None``"
msgstr "``x is None``"

#: ../Doc/library/unittest.rst:816
msgid ":meth:`assertIsNotNone(x) <TestCase.assertIsNotNone>`"
msgstr ":meth:`assertIsNotNone(x) <TestCase.assertIsNotNone>`"

#: ../Doc/library/unittest.rst:816
msgid "``x is not None``"
msgstr "``x is not None``"

#: ../Doc/library/unittest.rst:819
msgid ":meth:`assertIn(a, b) <TestCase.assertIn>`"
msgstr ":meth:`assertIn(a, b) <TestCase.assertIn>`"

#: ../Doc/library/unittest.rst:819
msgid "``a in b``"
msgstr "``a in b``"

#: ../Doc/library/unittest.rst:822
msgid ":meth:`assertNotIn(a, b) <TestCase.assertNotIn>`"
msgstr ":meth:`assertNotIn(a, b) <TestCase.assertNotIn>`"

#: ../Doc/library/unittest.rst:822
msgid "``a not in b``"
msgstr "``a not in b``"

#: ../Doc/library/unittest.rst:825
msgid ":meth:`assertIsInstance(a, b) <TestCase.assertIsInstance>`"
msgstr ":meth:`assertIsInstance(a, b) <TestCase.assertIsInstance>`"

#: ../Doc/library/unittest.rst:825
msgid "``isinstance(a, b)``"
msgstr "``isinstance(a, b)``"

#: ../Doc/library/unittest.rst:828
msgid ":meth:`assertNotIsInstance(a, b) <TestCase.assertNotIsInstance>`"
msgstr ":meth:`assertNotIsInstance(a, b) <TestCase.assertNotIsInstance>`"

#: ../Doc/library/unittest.rst:828
msgid "``not isinstance(a, b)``"
msgstr "``not isinstance(a, b)``"

#: ../Doc/library/unittest.rst:832
msgid ""
"All the assert methods (except :meth:`assertRaises`, :meth:"
"`assertRaisesRegexp`) accept a *msg* argument that, if specified, is used as "
"the error message on failure (see also :data:`longMessage`)."
msgstr ""

#: ../Doc/library/unittest.rst:839
msgid ""
"Test that *first* and *second* are equal.  If the values do not compare "
"equal, the test will fail."
msgstr ""
"Vérifie que *first* et *second* sont égaux.  Si les valeurs ne sont pas "
"égales, le test échouera."

#: ../Doc/library/unittest.rst:842
msgid ""
"In addition, if *first* and *second* are the exact same type and one of "
"list, tuple, dict, set, frozenset or unicode or any type that a subclass "
"registers with :meth:`addTypeEqualityFunc` the type-specific equality "
"function will be called in order to generate a more useful default error "
"message (see also the :ref:`list of type-specific methods <type-specific-"
"methods>`)."
msgstr ""

#: ../Doc/library/unittest.rst:849
msgid "Added the automatic calling of type-specific equality function."
msgstr ""
"Ajout de l'appel automatique de la fonction d'égalité spécifique au type."

#: ../Doc/library/unittest.rst:855
msgid ""
"Test that *first* and *second* are not equal.  If the values do compare "
"equal, the test will fail."
msgstr ""
"Vérifie que *first* et *second* ne sont pas égaux.  Si les valeurs sont "
"égales, le test échouera."

#: ../Doc/library/unittest.rst:861
msgid "Test that *expr* is true (or false)."
msgstr "Vérifie que *expr* est vraie (ou fausse)."

#: ../Doc/library/unittest.rst:863
msgid ""
"Note that this is equivalent to ``bool(expr) is True`` and not to ``expr is "
"True`` (use ``assertIs(expr, True)`` for the latter).  This method should "
"also be avoided when more specific methods are available (e.g. "
"``assertEqual(a, b)`` instead of ``assertTrue(a == b)``), because they "
"provide a better error message in case of failure."
msgstr ""
"Notez que cela revient à utiliser ``bool(expr) is True`` et non à ``expr is "
"True`` (utilisez ``assertIs(expr, True)`` pour cette dernière). Cette "
"méthode doit également être évitée lorsque des méthodes plus spécifiques "
"sont disponibles (par exemple ``assertEqual(a, b)`` au lieu de "
"``assertTrue(a == b)``), car elles fournissent un meilleur message d'erreur "
"en cas d' échec."

#: ../Doc/library/unittest.rst:873
msgid ""
"Test that *first* and *second* evaluate (or don't evaluate) to the same "
"object."
msgstr ""
"Vérifie que *first* et *second* évaluent (ou n'évaluent pas) le même objet."

#: ../Doc/library/unittest.rst:881
msgid "Test that *expr* is (or is not) ``None``."
msgstr "Vérifie que *expr* est (ou n'est pas) la valeur ``None``."

#: ../Doc/library/unittest.rst:889
msgid "Test that *first* is (or is not) in *second*."
msgstr "Vérifie que *first* est (ou n'est pas) dans *second*."

#: ../Doc/library/unittest.rst:897
msgid ""
"Test that *obj* is (or is not) an instance of *cls* (which can be a class or "
"a tuple of classes, as supported by :func:`isinstance`). To check for the "
"exact type, use :func:`assertIs(type(obj), cls) <assertIs>`."
msgstr ""
"Vérifie que *obj* est (ou n'est pas) une instance de *cls* (Ce qui peut être "
"une classe ou un tuple de classes, comme utilisée par :func:`isinstance`). "
"Pour vérifier le type exact, utilisez :func:`assertIs(type(obj), cls) "
"<assertIs>`."

#: ../Doc/library/unittest.rst:904
msgid ""
"It is also possible to check that exceptions and warnings are raised using "
"the following methods:"
msgstr ""

#: ../Doc/library/unittest.rst:910
msgid ":meth:`assertRaises(exc, fun, *args, **kwds) <TestCase.assertRaises>`"
msgstr ":meth:`assertRaises(exc, fun, *args, **kwds) <TestCase.assertRaises>`"

#: ../Doc/library/unittest.rst:910
msgid "``fun(*args, **kwds)`` raises *exc*"
msgstr "``fun(*args, **kwds)`` lève bien l'exception *exc*"

#: ../Doc/library/unittest.rst:913
msgid ""
":meth:`assertRaisesRegexp(exc, r, fun, *args, **kwds) <TestCase."
"assertRaisesRegexp>`"
msgstr ""

#: ../Doc/library/unittest.rst:913
msgid "``fun(*args, **kwds)`` raises *exc* and the message matches regex *r*"
msgstr ""
"``fun(*args, **kwds)`` lève bien l'exception *exc* et que le message "
"correspond au motif de l'expression régulière *r*"

#: ../Doc/library/unittest.rst:920
msgid ""
"Test that an exception is raised when *callable* is called with any "
"positional or keyword arguments that are also passed to :meth:"
"`assertRaises`.  The test passes if *exception* is raised, is an error if "
"another exception is raised, or fails if no exception is raised. To catch "
"any of a group of exceptions, a tuple containing the exception classes may "
"be passed as *exception*."
msgstr ""
"Vérifie qu'une exception est levée lorsque *callable* est appelé avec "
"n'importe quel argument positionnel ou mot-clé qui est également passé à :"
"meth:`assertRaises`.  Le test réussit si *exception* est levée, est en "
"erreur si une autre exception est levée, ou en échec si aucune exception "
"n'est levée. Pour capturer une exception d'un groupe d'exceptions, un couple "
"contenant les classes d'exceptions peut être passé à *exception*."

#: ../Doc/library/unittest.rst:927
msgid ""
"If only the *exception* argument is given, returns a context manager so that "
"the code under test can be written inline rather than as a function::"
msgstr ""

#: ../Doc/library/unittest.rst:933
msgid ""
"The context manager will store the caught exception object in its :attr:"
"`exception` attribute.  This can be useful if the intention is to perform "
"additional checks on the exception raised::"
msgstr ""
"Le gestionnaire de contexte enregistre l'exception capturée dans son "
"attribut :attr:`exception`. Ceci est particulièrement utile si l'intention "
"est d'effectuer des contrôles supplémentaires sur l'exception levée  ::"

#: ../Doc/library/unittest.rst:943
msgid "Added the ability to use :meth:`assertRaises` as a context manager."
msgstr ""
"Ajout de la possibilité d'utiliser :meth:`assertRaises` comme gestionnaire "
"de contexte."

#: ../Doc/library/unittest.rst:950
msgid ""
"Like :meth:`assertRaises` but also tests that *regexp* matches on the string "
"representation of the raised exception.  *regexp* may be a regular "
"expression object or a string containing a regular expression suitable for "
"use by :func:`re.search`.  Examples::"
msgstr ""

#: ../Doc/library/unittest.rst:958
msgid "or::"
msgstr "ou : ::"

#: ../Doc/library/unittest.rst:967
msgid ""
"There are also other methods used to perform more specific checks, such as:"
msgstr ""
"Il existe également d'autres méthodes utilisées pour effectuer des contrôles "
"plus spécifiques, telles que  ::"

#: ../Doc/library/unittest.rst:972
msgid ":meth:`assertAlmostEqual(a, b) <TestCase.assertAlmostEqual>`"
msgstr ":meth:`assertAlmostEqual(a, b) <TestCase.assertAlmostEqual>`"

#: ../Doc/library/unittest.rst:972
msgid "``round(a-b, 7) == 0``"
msgstr "``round(a-b, 7) == 0``"

#: ../Doc/library/unittest.rst:975
msgid ":meth:`assertNotAlmostEqual(a, b) <TestCase.assertNotAlmostEqual>`"
msgstr ":meth:`assertNotAlmostEqual(a, b) <TestCase.assertNotAlmostEqual>`"

#: ../Doc/library/unittest.rst:975
msgid "``round(a-b, 7) != 0``"
msgstr "``round(a-b, 7) != 0``"

#: ../Doc/library/unittest.rst:978
msgid ":meth:`assertGreater(a, b) <TestCase.assertGreater>`"
msgstr ":meth:`assertGreater(a, b) <TestCase.assertGreater>`"

#: ../Doc/library/unittest.rst:978
msgid "``a > b``"
msgstr "``a > b``"

#: ../Doc/library/unittest.rst:981
msgid ":meth:`assertGreaterEqual(a, b) <TestCase.assertGreaterEqual>`"
msgstr ":meth:`assertGreaterEqual(a, b) <TestCase.assertGreaterEqual>`"

#: ../Doc/library/unittest.rst:981
msgid "``a >= b``"
msgstr "``a >= b``"

#: ../Doc/library/unittest.rst:984
msgid ":meth:`assertLess(a, b) <TestCase.assertLess>`"
msgstr ":meth:`assertLess(a, b) <TestCase.assertLess>`"

#: ../Doc/library/unittest.rst:984
msgid "``a < b``"
msgstr "``a < b``"

#: ../Doc/library/unittest.rst:987
msgid ":meth:`assertLessEqual(a, b) <TestCase.assertLessEqual>`"
msgstr ":meth:`assertLessEqual(a, b) <TestCase.assertLessEqual>`"

#: ../Doc/library/unittest.rst:987
msgid "``a <= b``"
msgstr "``a <= b``"

#: ../Doc/library/unittest.rst:990
msgid ":meth:`assertRegexpMatches(s, r) <TestCase.assertRegexpMatches>`"
msgstr ""

#: ../Doc/library/unittest.rst:990
msgid "``r.search(s)``"
msgstr "``r.search(s)``"

#: ../Doc/library/unittest.rst:993
msgid ":meth:`assertNotRegexpMatches(s, r) <TestCase.assertNotRegexpMatches>`"
msgstr ""

#: ../Doc/library/unittest.rst:993
msgid "``not r.search(s)``"
msgstr "``not r.search(s)``"

#: ../Doc/library/unittest.rst:996
msgid ":meth:`assertItemsEqual(a, b) <TestCase.assertItemsEqual>`"
msgstr ""

#: ../Doc/library/unittest.rst:996
msgid "sorted(a) == sorted(b) and works with unhashable objs"
msgstr ""

#: ../Doc/library/unittest.rst:999
msgid ""
":meth:`assertDictContainsSubset(a, b) <TestCase.assertDictContainsSubset>`"
msgstr ""

#: ../Doc/library/unittest.rst:999
msgid "all the key/value pairs in *a* exist in *b*"
msgstr ""

#: ../Doc/library/unittest.rst:1007
msgid ""
"Test that *first* and *second* are approximately (or not approximately) "
"equal by computing the difference, rounding to the given number of decimal "
"*places* (default 7), and comparing to zero.  Note that these methods round "
"the values to the given number of *decimal places* (i.e. like the :func:"
"`round` function) and not *significant digits*."
msgstr ""
"Vérifie que *first* et *second* sont approximativement (ou pas "
"approximativement) égaux en calculant la différence, en arrondissant au "
"nombre donné de décimales *places* (par défaut 7), et en comparant à zéro. "
"Notez que ces méthodes arrondissent les valeurs au nombre donné de "
"*décimales* (par exemple comme la fonction :func:`round`) et non aux "
"*chiffres significatifs*."

#: ../Doc/library/unittest.rst:1013
msgid ""
"If *delta* is supplied instead of *places* then the difference between "
"*first* and *second* must be less or equal to (or greater than) *delta*."
msgstr ""
"Si *delta* est fourni au lieu de *places*, la différence entre *first* et "
"*second* doit être inférieure ou égale (ou supérieure) à *delta*."

#: ../Doc/library/unittest.rst:1016
msgid "Supplying both *delta* and *places* raises a ``TypeError``."
msgstr ""

#: ../Doc/library/unittest.rst:1018
msgid ""
":meth:`assertAlmostEqual` automatically considers almost equal objects that "
"compare equal.  :meth:`assertNotAlmostEqual` automatically fails if the "
"objects compare equal.  Added the *delta* keyword argument."
msgstr ""
":meth:`assertAlmostEqual` considère automatiquement des objets presque égaux "
"qui se comparent égaux. :meth:`assertNotNotAlmostEqual` échoue "
"automatiquement si les objets qui se comparent sont égaux.  Ajout de "
"l'argument mot-clé *delta*."

#: ../Doc/library/unittest.rst:1030
msgid ""
"Test that *first* is respectively >, >=, < or <= than *second* depending on "
"the method name.  If not, the test will fail::"
msgstr ""
"Vérifie que *first* est respectivement >, >=, >=, < ou <= à *second* selon "
"le nom de la méthode.  Sinon, le test échouera  ::"

#: ../Doc/library/unittest.rst:1041
msgid ""
"Test that a *regexp* search matches *text*.  In case of failure, the error "
"message will include the pattern and the *text* (or the pattern and the part "
"of *text* that unexpectedly matched).  *regexp* may be a regular expression "
"object or a string containing a regular expression suitable for use by :func:"
"`re.search`."
msgstr ""

#: ../Doc/library/unittest.rst:1052
msgid ""
"Verifies that a *regexp* search does not match *text*.  Fails with an error "
"message including the pattern and the part of *text* that matches.  *regexp* "
"may be a regular expression object or a string containing a regular "
"expression suitable for use by :func:`re.search`."
msgstr ""

#: ../Doc/library/unittest.rst:1062
msgid ""
"Test that sequence *expected* contains the same elements as *actual*, "
"regardless of their order. When they don't, an error message listing the "
"differences between the sequences will be generated."
msgstr ""

#: ../Doc/library/unittest.rst:1066
msgid ""
"Duplicate elements are *not* ignored when comparing *actual* and *expected*. "
"It verifies if each element has the same count in both sequences. It is the "
"equivalent of ``assertEqual(sorted(expected), sorted(actual))`` but it works "
"with sequences of unhashable objects as well."
msgstr ""

#: ../Doc/library/unittest.rst:1072
msgid "In Python 3, this method is named ``assertCountEqual``."
msgstr ""

#: ../Doc/library/unittest.rst:1079
msgid ""
"Tests whether the key/value pairs in dictionary *actual* are a superset of "
"those in *expected*.  If not, an error message listing the missing keys and "
"mismatched values is generated."
msgstr ""

#: ../Doc/library/unittest.rst:1090
msgid ""
"The :meth:`assertEqual` method dispatches the equality check for objects of "
"the same type to different type-specific methods.  These methods are already "
"implemented for most of the built-in types, but it's also possible to "
"register new methods using :meth:`addTypeEqualityFunc`:"
msgstr ""
"La méthode :meth:`assertEqual` envoie le contrôle d'égalité pour les objets "
"du même type à différentes méthodes spécifiques au type. Ces méthodes sont "
"déjà implémentées pour la plupart des types intégrés, mais il est également "
"possible d'enregistrer de nouvelles méthodes en utilisant :meth:"
"`addTypeEqualityFunc`  ::"

#: ../Doc/library/unittest.rst:1097
msgid ""
"Registers a type-specific method called by :meth:`assertEqual` to check if "
"two objects of exactly the same *typeobj* (not subclasses) compare equal.  "
"*function* must take two positional arguments and a third msg=None keyword "
"argument just as :meth:`assertEqual` does.  It must raise :data:`self."
"failureException(msg) <failureException>` when inequality between the first "
"two parameters is detected -- possibly providing useful information and "
"explaining the inequalities in details in the error message."
msgstr ""
"Enregistre une méthode spécifique appelée par :meth:`assertEqual` pour "
"vérifier si deux objets exactement du même *typeobj* (et non leurs sous-"
"classes) sont égaux. *function* doit prendre deux arguments positionnels et "
"un troisième argument mot-clé *msg=None* tout comme :meth:`assertEqual` le "
"fait. Il doit lever :data:`self.failureException(msg) <failureException>` "
"lorsqu'une inégalité entre les deux premiers paramètres est détectée en "
"fournissant éventuellement des informations utiles et expliquant l'inégalité "
"en détail dans le message d'erreur."

#: ../Doc/library/unittest.rst:1108
msgid ""
"The list of type-specific methods automatically used by :meth:`~TestCase."
"assertEqual` are summarized in the following table.  Note that it's usually "
"not necessary to invoke these methods directly."
msgstr ""
"La liste des méthodes spécifiques utilisées automatiquement par :meth:"
"`~TestCase.assertEqual` est résumée dans le tableau suivant.  Notez qu'il "
"n'est généralement pas nécessaire d'invoquer ces méthodes directement."

#: ../Doc/library/unittest.rst:1113
msgid "Used to compare"
msgstr "Utilisé pour comparer"

#: ../Doc/library/unittest.rst:1115
msgid ":meth:`assertMultiLineEqual(a, b) <TestCase.assertMultiLineEqual>`"
msgstr ":meth:`assertMultiLineEqual(a, b) <TestCase.assertMultiLineEqual>`"

#: ../Doc/library/unittest.rst:1115
msgid "strings"
msgstr "chaînes"

#: ../Doc/library/unittest.rst:1118
msgid ":meth:`assertSequenceEqual(a, b) <TestCase.assertSequenceEqual>`"
msgstr ":meth:`assertSequenceEqual(a, b) <TestCase.assertSequenceEqual>`"

#: ../Doc/library/unittest.rst:1118
msgid "sequences"
msgstr "séquences"

#: ../Doc/library/unittest.rst:1121
msgid ":meth:`assertListEqual(a, b) <TestCase.assertListEqual>`"
msgstr ":meth:`assertListEqual(a, b) <TestCase.assertListEqual>`"

#: ../Doc/library/unittest.rst:1121
msgid "lists"
msgstr "listes"

#: ../Doc/library/unittest.rst:1124
msgid ":meth:`assertTupleEqual(a, b) <TestCase.assertTupleEqual>`"
msgstr ":meth:`assertTupleEqual(a, b) <TestCase.assertTupleEqual>`"

#: ../Doc/library/unittest.rst:1124
msgid "tuples"
msgstr "n-uplets"

#: ../Doc/library/unittest.rst:1127
msgid ":meth:`assertSetEqual(a, b) <TestCase.assertSetEqual>`"
msgstr ":meth:`assertSetEqual(a, b) <TestCase.assertSetEqual>`"

#: ../Doc/library/unittest.rst:1127
msgid "sets or frozensets"
msgstr "*sets* ou *frozensets*"

#: ../Doc/library/unittest.rst:1130
msgid ":meth:`assertDictEqual(a, b) <TestCase.assertDictEqual>`"
msgstr ":meth:`assertDictEqual(a, b) <TestCase.assertDictEqual>`"

#: ../Doc/library/unittest.rst:1130
msgid "dicts"
msgstr "dictionnaires"

#: ../Doc/library/unittest.rst:1138
msgid ""
"Test that the multiline string *first* is equal to the string *second*. When "
"not equal a diff of the two strings highlighting the differences will be "
"included in the error message. This method is used by default when comparing "
"strings with :meth:`assertEqual`."
msgstr ""
"Vérifie que la chaîne sur plusieurs lignes *first* est égale à la chaîne "
"*second*. Si les deux chaînes de caractères ne sont pas égales, un *diff* "
"mettant en évidence les différences est inclus dans le message d'erreur. "
"Cette méthode est utilisée par défaut pour comparer les chaînes avec :meth:"
"`assertEqual`."

#: ../Doc/library/unittest.rst:1148
msgid ""
"Tests that two sequences are equal.  If a *seq_type* is supplied, both "
"*seq1* and *seq2* must be instances of *seq_type* or a failure will be "
"raised.  If the sequences are different an error message is constructed that "
"shows the difference between the two."
msgstr ""

#: ../Doc/library/unittest.rst:1153
msgid ""
"This method is not called directly by :meth:`assertEqual`, but it's used to "
"implement :meth:`assertListEqual` and :meth:`assertTupleEqual`."
msgstr ""
"Cette méthode n'est pas appelée directement par :meth:`assertEqual`, mais "
"sert à implémenter :meth:`assertListEqual` et :meth:`assertTupleEqual`."

#: ../Doc/library/unittest.rst:1163
msgid ""
"Tests that two lists or tuples are equal.  If not, an error message is "
"constructed that shows only the differences between the two.  An error is "
"also raised if either of the parameters are of the wrong type. These methods "
"are used by default when comparing lists or tuples with :meth:`assertEqual`."
msgstr ""
"Vérifie que deux listes ou deux n-uplets sont égaux.  Si ce n'est pas le "
"cas, un message d'erreur qui ne montre que les différences entre les deux "
"est généré.  Une erreur est également signalée si l'un ou l'autre des "
"paramètres n'est pas du bon type. Ces méthodes sont utilisées par défaut "
"pour comparer des listes ou des couples avec :meth:`assertEqual`."

#: ../Doc/library/unittest.rst:1174
msgid ""
"Tests that two sets are equal.  If not, an error message is constructed that "
"lists the differences between the sets.  This method is used by default when "
"comparing sets or frozensets with :meth:`assertEqual`."
msgstr ""
"Vérifie que deux ensembles sont égaux. Si ce n'est pas le cas, un message "
"d'erreur s'affiche et indique les différences entre les *sets*. Cette "
"méthode est utilisée par défaut lors de la comparaison de *sets* ou de "
"*frozensets* avec :meth:`assertEqual`."

#: ../Doc/library/unittest.rst:1178
msgid ""
"Fails if either of *set1* or *set2* does not have a :meth:`set.difference` "
"method."
msgstr ""

#: ../Doc/library/unittest.rst:1186
msgid ""
"Test that two dictionaries are equal.  If not, an error message is "
"constructed that shows the differences in the dictionaries. This method will "
"be used by default to compare dictionaries in calls to :meth:`assertEqual`."
msgstr ""
"Vérifie que deux dictionnaires sont égaux. Si ce n'est pas le cas, un "
"message d'erreur qui montre les différences dans les dictionnaires est "
"généré. Cette méthode est utilisée par défaut pour comparer les "
"dictionnaires dans les appels à :meth:`assertEqual`."

#: ../Doc/library/unittest.rst:1197
msgid ""
"Finally the :class:`TestCase` provides the following methods and attributes:"
msgstr ""
"Enfin, la classe :class:`TestCase` fournit les méthodes et attributs "
"suivants :"

#: ../Doc/library/unittest.rst:1202
msgid ""
"Signals a test failure unconditionally, with *msg* or ``None`` for the error "
"message."
msgstr ""
"Indique un échec du test sans condition, avec *msg* ou ``None`` pour le "
"message d'erreur."

#: ../Doc/library/unittest.rst:1208
msgid ""
"This class attribute gives the exception raised by the test method.  If a "
"test framework needs to use a specialized exception, possibly to carry "
"additional information, it must subclass this exception in order to \"play "
"fair\" with the framework.  The initial value of this attribute is :exc:"
"`AssertionError`."
msgstr ""
"Cet attribut de classe donne l'exception levée par la méthode de test.  Si "
"un *framework* de tests doit utiliser une exception spécialisée, "
"probablement pour enrichir l'exception d'informations additionnels., il doit "
"hériter de cette classe d'exception pour *bien fonctionner*  avec le "
"*framework*. La valeur initiale de cet attribut est :exc:`AssertionError`."

#: ../Doc/library/unittest.rst:1217
msgid ""
"If set to ``True`` then any explicit failure message you pass in to the :ref:"
"`assert methods <assert-methods>` will be appended to the end of the normal "
"failure message.  The normal messages contain useful information about the "
"objects involved, for example the message from assertEqual shows you the "
"repr of the two unequal objects. Setting this attribute to ``True`` allows "
"you to have a custom error message in addition to the normal one."
msgstr ""

#: ../Doc/library/unittest.rst:1225
msgid ""
"This attribute defaults to ``False``, meaning that a custom message passed "
"to an assert method will silence the normal message."
msgstr ""

#: ../Doc/library/unittest.rst:1228
msgid ""
"The class setting can be overridden in individual tests by assigning an "
"instance attribute to ``True`` or ``False`` before calling the assert "
"methods."
msgstr ""

#: ../Doc/library/unittest.rst:1236
msgid ""
"This attribute controls the maximum length of diffs output by assert methods "
"that report diffs on failure. It defaults to 80*8 characters. Assert methods "
"affected by this attribute are :meth:`assertSequenceEqual` (including all "
"the sequence comparison methods that delegate to it), :meth:"
"`assertDictEqual` and :meth:`assertMultiLineEqual`."
msgstr ""
"Cet attribut contrôle la longueur maximale des *diffs* en sortie des "
"méthodes qui génèrent des *diffs* en cas d'échec. La valeur par défaut est "
"80*8 caractères. Les méthodes d'assertions affectées par cet attribut sont :"
"meth:`assertSequenceEqual` (y compris toutes les méthodes de comparaison de "
"séquences qui lui sont déléguées), :meth:`assertDictEqual` et :meth:"
"`assertMultiLineEqual`."

#: ../Doc/library/unittest.rst:1243
msgid ""
"Setting ``maxDiff`` to ``None`` means that there is no maximum length of "
"diffs."
msgstr ""
"Régler ``maxDiff`` sur ``None``` signifie qu'il n'y a pas de longueur "
"maximale pour les *diffs*."

#: ../Doc/library/unittest.rst:1249
msgid ""
"Testing frameworks can use the following methods to collect information on "
"the test:"
msgstr ""
"Les *frameworks* de test peuvent utiliser les méthodes suivantes pour "
"recueillir des informations sur le test :"

#: ../Doc/library/unittest.rst:1255
msgid ""
"Return the number of tests represented by this test object.  For :class:"
"`TestCase` instances, this will always be ``1``."
msgstr ""
"Renvoie le nombre de tests représentés par cet objet test. Pour les "
"instances de :class:`TestCase`, c'est toujours ``1``."

#: ../Doc/library/unittest.rst:1261
msgid ""
"Return an instance of the test result class that should be used for this "
"test case class (if no other result instance is provided to the :meth:`run` "
"method)."
msgstr ""
"Retourne une instance de la classe de résultat de test qui doit être "
"utilisée pour cette classe de cas de test (si aucune autre instance de "
"résultat n'est fournie à la méthode :meth:`run`)."

#: ../Doc/library/unittest.rst:1265
msgid ""
"For :class:`TestCase` instances, this will always be an instance of :class:"
"`TestResult`; subclasses of :class:`TestCase` should override this as "
"necessary."
msgstr ""
"Pour les instances de :class:`TestCase`, c'est toujours une instance de :"
"class:`TestResult` ; les sous-classes de :class:`TestCase` peuvent la "
"remplacer au besoin."

#: ../Doc/library/unittest.rst:1272
msgid ""
"Return a string identifying the specific test case.  This is usually the "
"full name of the test method, including the module and class name."
msgstr ""
"Retourne une chaîne identifiant le cas de test spécifique. Il s'agit "
"généralement du nom complet de la méthode de test, y compris le nom du "
"module et de la classe."

#: ../Doc/library/unittest.rst:1278
msgid ""
"Returns a description of the test, or ``None`` if no description has been "
"provided.  The default implementation of this method returns the first line "
"of the test method's docstring, if available, or :const:`None`."
msgstr ""

#: ../Doc/library/unittest.rst:1287
msgid ""
"Add a function to be called after :meth:`tearDown` to cleanup resources used "
"during the test. Functions will be called in reverse order to the order they "
"are added (LIFO). They are called with any arguments and keyword arguments "
"passed into :meth:`addCleanup` when they are added."
msgstr ""

#: ../Doc/library/unittest.rst:1293
msgid ""
"If :meth:`setUp` fails, meaning that :meth:`tearDown` is not called, then "
"any cleanup functions added will still be called."
msgstr ""
"Si :meth:`setUp` échoue, cela signifie que :meth:`tearDown` n'est pas "
"appelé, alors que les fonctions de nettoyage ajoutées seront toujours "
"appelées."

#: ../Doc/library/unittest.rst:1301
msgid ""
"This method is called unconditionally after :meth:`tearDown`, or after :meth:"
"`setUp` if :meth:`setUp` raises an exception."
msgstr ""
"Cette méthode est appelée sans conditions après :meth:`tearDown`, ou après :"
"meth:`setUp` si :meth:`setUp` lève une exception."

#: ../Doc/library/unittest.rst:1304
msgid ""
"It is responsible for calling all the cleanup functions added by :meth:"
"`addCleanup`. If you need cleanup functions to be called *prior* to :meth:"
"`tearDown` then you can call :meth:`doCleanups` yourself."
msgstr ""
"Cette méthode est chargée d'appeler toutes les fonctions de nettoyage "
"ajoutées par :meth:`addCleanup`. Si vous avez besoin de fonctions de "
"nettoyage à appeler *avant* l'appel à :meth:`tearDown` alors vous pouvez "
"appeler :meth:`doCleanups` vous-même."

#: ../Doc/library/unittest.rst:1309
msgid ""
":meth:`doCleanups` pops methods off the stack of cleanup functions one at a "
"time, so it can be called at any time."
msgstr ""
":meth:`doCleanups` extrait les méthodes de la pile des fonctions de "
"nettoyage une à la fois, de sorte qu'elles peuvent être appelées à tout "
"moment."

#: ../Doc/library/unittest.rst:1317
msgid ""
"This class implements the portion of the :class:`TestCase` interface which "
"allows the test runner to drive the test, but does not provide the methods "
"which test code can use to check and report errors.  This is used to create "
"test cases using legacy test code, allowing it to be integrated into a :mod:"
"`unittest`-based test framework."
msgstr ""
"Cette classe implémente la partie de l'interface :class:`TestCase` qui "
"permet au lanceur de test de piloter le scénario de test, mais ne fournit "
"pas les méthodes que le code test peut utiliser pour vérifier et signaler "
"les erreurs. Ceci est utilisé pour créer des scénario de test utilisant du "
"code de test existant afin de faciliter l'intégration dans un *framework* de "
"test basé sur :mod:`unittest`."

#: ../Doc/library/unittest.rst:1325
msgid "Deprecated aliases"
msgstr "Alias obsolètes"

#: ../Doc/library/unittest.rst:1327
msgid ""
"For historical reasons, some of the :class:`TestCase` methods had one or "
"more aliases that are now deprecated.  The following table lists the correct "
"names along with their deprecated aliases:"
msgstr ""
"Pour des raisons historiques, certaines méthodes de la classe :class:"
"`TestCase` avaient un ou plusieurs alias qui sont maintenant obsolètes. Le "
"tableau suivant énumère les noms corrects ainsi que leurs alias obsolètes  ::"

#: ../Doc/library/unittest.rst:1332
msgid "Method Name"
msgstr "Nom de méthode"

#: ../Doc/library/unittest.rst:1332
msgid "Deprecated alias(es)"
msgstr ""

#: ../Doc/library/unittest.rst:1334
msgid ":meth:`.assertEqual`"
msgstr ":meth:`.assertEqual`"

#: ../Doc/library/unittest.rst:1334
msgid "failUnlessEqual, assertEquals"
msgstr ""

#: ../Doc/library/unittest.rst:1335
msgid ":meth:`.assertNotEqual`"
msgstr ":meth:`.assertNotEqual`"

#: ../Doc/library/unittest.rst:1335
msgid "failIfEqual"
msgstr "failIfEqual"

#: ../Doc/library/unittest.rst:1336
msgid ":meth:`.assertTrue`"
msgstr ":meth:`.assertTrue`"

#: ../Doc/library/unittest.rst:1336
msgid "failUnless, assert\\_"
msgstr ""

#: ../Doc/library/unittest.rst:1337
msgid ":meth:`.assertFalse`"
msgstr ":meth:`.assertFalse`"

#: ../Doc/library/unittest.rst:1337
msgid "failIf"
msgstr "failIf"

#: ../Doc/library/unittest.rst:1338
msgid ":meth:`.assertRaises`"
msgstr ":meth:`.assertRaises`"

#: ../Doc/library/unittest.rst:1338
msgid "failUnlessRaises"
msgstr "failUnlessRaises"

#: ../Doc/library/unittest.rst:1339
msgid ":meth:`.assertAlmostEqual`"
msgstr ":meth:`.assertAlmostEqual`"

#: ../Doc/library/unittest.rst:1339
msgid "failUnlessAlmostEqual"
msgstr "failUnlessAlmostEqual"

#: ../Doc/library/unittest.rst:1340
msgid ":meth:`.assertNotAlmostEqual`"
msgstr ":meth:`.assertNotAlmostEqual`"

#: ../Doc/library/unittest.rst:1340
msgid "failIfAlmostEqual"
msgstr "failIfAlmostEqual"

#: ../Doc/library/unittest.rst:1343
msgid "the aliases listed in the second column"
msgstr ""

#: ../Doc/library/unittest.rst:1351
msgid "Grouping tests"
msgstr "Regroupement des tests"

#: ../Doc/library/unittest.rst:1355
msgid ""
"This class represents an aggregation of individual tests cases and test "
"suites. The class presents the interface needed by the test runner to allow "
"it to be run as any other test case.  Running a :class:`TestSuite` instance "
"is the same as iterating over the suite, running each test individually."
msgstr ""

#: ../Doc/library/unittest.rst:1360
msgid ""
"If *tests* is given, it must be an iterable of individual test cases or "
"other test suites that will be used to build the suite initially. Additional "
"methods are provided to add test cases and suites to the collection later on."
msgstr ""
"Si *tests* est fourni, il doit s'agir d'un itérable de cas de test "
"individuels ou d'autres suites de test qui seront utilisés pour construire "
"la suite initial. Des méthodes supplémentaires sont fournies pour ajouter "
"ultérieurement des cas de test et des suites à la collection."

#: ../Doc/library/unittest.rst:1364
msgid ""
":class:`TestSuite` objects behave much like :class:`TestCase` objects, "
"except they do not actually implement a test.  Instead, they are used to "
"aggregate tests into groups of tests that should be run together. Some "
"additional methods are available to add tests to :class:`TestSuite` "
"instances:"
msgstr ""
"Les objets :class:`TestSuite` se comportent comme les objets :class:"
"`TestCase`, sauf qu'ils n'implémentent pas réellement un test. Au lieu de "
"cela, ils sont utilisés pour regrouper les tests en groupes de tests qui "
"doivent être exécutés ensemble. Des méthodes supplémentaires sont "
"disponibles pour ajouter des tests aux instances de :class:`TestSuite` :"

#: ../Doc/library/unittest.rst:1372
msgid "Add a :class:`TestCase` or :class:`TestSuite` to the suite."
msgstr ""
"Ajouter un objet :class:`TestCase` ou :class:`TestSuite` à la suite de tests."

#: ../Doc/library/unittest.rst:1377
msgid ""
"Add all the tests from an iterable of :class:`TestCase` and :class:"
"`TestSuite` instances to this test suite."
msgstr ""
"Ajouter tous les tests d'un itérable d'instances de :class:`TestCase` et de :"
"class:`TestSuite` à cette suite de tests."

#: ../Doc/library/unittest.rst:1380
msgid ""
"This is equivalent to iterating over *tests*, calling :meth:`addTest` for "
"each element."
msgstr ""
"C'est l'équivalent d'une itération sur *tests*, appelant :meth:`addTest` "
"pour chaque élément."

#: ../Doc/library/unittest.rst:1383
msgid ":class:`TestSuite` shares the following methods with :class:`TestCase`:"
msgstr ""
":class:`TestSuite` partage les méthodes suivantes avec :class:`TestCase` :"

#: ../Doc/library/unittest.rst:1388
msgid ""
"Run the tests associated with this suite, collecting the result into the "
"test result object passed as *result*.  Note that unlike :meth:`TestCase."
"run`, :meth:`TestSuite.run` requires the result object to be passed in."
msgstr ""
"Exécute les tests associés à cette suite, en collectant le résultat dans "
"l'objet de résultat de test passé par *result*.  Remarquer que contrairement "
"à :meth:`TestCase.run`, :meth:`TestSuite.run` nécessite que l'objet résultat "
"soit passé."

#: ../Doc/library/unittest.rst:1396
msgid ""
"Run the tests associated with this suite without collecting the result. This "
"allows exceptions raised by the test to be propagated to the caller and can "
"be used to support running tests under a debugger."
msgstr ""
"Exécute les tests associés à cette suite sans collecter le résultat. Ceci "
"permet aux exceptions levées par le test d'être propagées à l'appelant et "
"peut être utilisé pour exécuter des tests sous un débogueur."

#: ../Doc/library/unittest.rst:1403
msgid ""
"Return the number of tests represented by this test object, including all "
"individual tests and sub-suites."
msgstr ""
"Renvoie le nombre de tests représentés par cet objet de test, y compris tous "
"les tests individuels et les sous-suites."

#: ../Doc/library/unittest.rst:1409
msgid ""
"Tests grouped by a :class:`TestSuite` are always accessed by iteration. "
"Subclasses can lazily provide tests by overriding :meth:`__iter__`. Note "
"that this method maybe called several times on a single suite (for example "
"when counting tests or comparing for equality) so the tests returned must be "
"the same for repeated iterations."
msgstr ""

#: ../Doc/library/unittest.rst:1415
msgid ""
"In earlier versions the :class:`TestSuite` accessed tests directly rather "
"than through iteration, so overriding :meth:`__iter__` wasn't sufficient for "
"providing tests."
msgstr ""
"Dans les versions précédentes, la classe :class:`TestSuite` accédait aux "
"tests directement plutôt que par itération, donc surcharger la méthode :meth:"
"`__iter__` n'était pas suffisante pour fournir les tests."

#: ../Doc/library/unittest.rst:1420
msgid ""
"In the typical usage of a :class:`TestSuite` object, the :meth:`run` method "
"is invoked by a :class:`TestRunner` rather than by the end-user test harness."
msgstr ""
"Dans l'utilisation typique de l'objet :class:`TestSuite`, la méthode :meth:"
"`run` est invoquée par une classe :class:`TestRunner` plutôt que par le "
"système de test de l'utilisateur."

#: ../Doc/library/unittest.rst:1425
msgid "Loading and running tests"
msgstr "Chargement et exécution des tests"

#: ../Doc/library/unittest.rst:1429
msgid ""
"The :class:`TestLoader` class is used to create test suites from classes and "
"modules.  Normally, there is no need to create an instance of this class; "
"the :mod:`unittest` module provides an instance that can be shared as :data:"
"`unittest.defaultTestLoader`.  Using a subclass or instance, however, allows "
"customization of some configurable properties."
msgstr ""
"La classe :class:`TestLoader` est utilisée pour créer des suites de tests à "
"partir de classes et de modules. Normalement, il n'est pas nécessaire de "
"créer une instance de cette classe ; le module :mod:`unittest` fournit une "
"instance qui peut être partagée comme :data:`unittest.defaultTestLoader`. "
"L'utilisation d'une sous-classe ou d'une instance permet cependant de "
"personnaliser certaines propriétés configurables."

#: ../Doc/library/unittest.rst:1435
msgid ":class:`TestLoader` objects have the following methods:"
msgstr ""
"Les objets de la classe :class:`TestLoader` ont les attributs suivants :"

#: ../Doc/library/unittest.rst:1440
msgid ""
"Return a suite of all tests cases contained in the :class:`TestCase`\\ -"
"derived :class:`testCaseClass`."
msgstr ""

#: ../Doc/library/unittest.rst:1446
msgid ""
"Return a suite of all tests cases contained in the given module. This method "
"searches *module* for classes derived from :class:`TestCase` and creates an "
"instance of the class for each test method defined for the class."
msgstr ""

#: ../Doc/library/unittest.rst:1453
msgid ""
"While using a hierarchy of :class:`TestCase`\\ -derived classes can be "
"convenient in sharing fixtures and helper functions, defining test methods "
"on base classes that are not intended to be instantiated directly does not "
"play well with this method.  Doing so, however, can be useful when the "
"fixtures are different and defined in subclasses."
msgstr ""
"Bien que l'utilisation d'une hiérarchie de classes :class:`TestCase` (les "
"classes dérivées de *TestCase*) peut être un moyen pratique de partager des "
"*fixtures* et des fonctions utilitaires, définir une méthode de test pour "
"des classes de base non destinées à être directement instanciée ne marche "
"pas bien avec cette méthode. Cela peut toutefois s'avérer utile lorsque les "
"*fixtures* sont différentes et définies dans des sous-classes."

#: ../Doc/library/unittest.rst:1459
msgid ""
"If a module provides a ``load_tests`` function it will be called to load the "
"tests. This allows modules to customize test loading. This is the "
"`load_tests protocol`_."
msgstr ""

#: ../Doc/library/unittest.rst:1463
msgid "Support for ``load_tests`` added."
msgstr "Ajout de la prise en charge de ``load_tests``."

#: ../Doc/library/unittest.rst:1469
msgid "Return a suite of all tests cases given a string specifier."
msgstr ""

#: ../Doc/library/unittest.rst:1471
msgid ""
"The specifier *name* is a \"dotted name\" that may resolve either to a "
"module, a test case class, a test method within a test case class, a :class:"
"`TestSuite` instance, or a callable object which returns a :class:`TestCase` "
"or :class:`TestSuite` instance.  These checks are applied in the order "
"listed here; that is, a method on a possible test case class will be picked "
"up as \"a test method within a test case class\", rather than \"a callable "
"object\"."
msgstr ""
"Le spécificateur *name* est un \"nom pointillé\" qui peut être résolu soit "
"par un module, une classe de cas de test, une méthode de test dans une "
"classe de cas de test, une instance de :class:`TestSuite`, ou un objet "
"appelable qui retourne une instance de classe :class:`TestCase` ou de "
"classe :class:`TestSuite`. Ces contrôles sont appliqués dans l'ordre indiqué "
"ici, c'est-à-dire qu'une méthode sur une classe de cas de test possible sera "
"choisie comme \"méthode de test dans une classe de cas de test\", plutôt que "
"comme \"un objet appelable\"."

#: ../Doc/library/unittest.rst:1479
msgid ""
"For example, if you have a module :mod:`SampleTests` containing a :class:"
"`TestCase`\\ -derived class :class:`SampleTestCase` with three test methods "
"(:meth:`test_one`, :meth:`test_two`, and :meth:`test_three`), the specifier "
"``'SampleTests.SampleTestCase'`` would cause this method to return a suite "
"which will run all three test methods. Using the specifier ``'SampleTests."
"SampleTestCase.test_two'`` would cause it to return a test suite which will "
"run only the :meth:`test_two` test method. The specifier can refer to "
"modules and packages which have not been imported; they will be imported as "
"a side-effect."
msgstr ""
"Par exemple, si vous avez un module :mod:`SampleTests` contenant une classe :"
"class:`TestCase` (classe dérivée de la classe :class:`SampleTestCase`) avec "
"trois méthodes de test (:meth:`test_one`, :meth:`test_two` et :meth:"
"`test_three`), l'élément spécificateur `SampleTests.sampleTestCase` renvoie "
"une suite qui va exécuter les trois méthodes de tests. L'utilisation du "
"spécificateur `SampleTests.SampleTestCase.test_two` permettrait de retourner "
"une suite de tests qui ne lancerait que la méthode test :meth:`test_two`. Le "
"spécificateur peut se référer à des modules et packages qui n'ont pas été "
"importés. Ils seront importés par un effet de bord."

#: ../Doc/library/unittest.rst:1489
msgid "The method optionally resolves *name* relative to the given *module*."
msgstr "La méthode résout facultativement *name* relatif au *module* donné."

#: ../Doc/library/unittest.rst:1494
msgid ""
"Similar to :meth:`loadTestsFromName`, but takes a sequence of names rather "
"than a single name.  The return value is a test suite which supports all the "
"tests defined for each name."
msgstr ""
"Similaire à :meth:`loadTestsFromName`, mais prend une séquence de noms "
"plutôt qu'un seul nom.  La valeur renvoyée est une suite de tests qui gère "
"tous les tests définis pour chaque nom."

#: ../Doc/library/unittest.rst:1501
msgid ""
"Return a sorted sequence of method names found within *testCaseClass*; this "
"should be a subclass of :class:`TestCase`."
msgstr ""
"Renvoie une séquence triée de noms de méthodes trouvés dans "
"*testCaseClass* ; ceci doit être une sous-classe de :class:`TestCase`."

#: ../Doc/library/unittest.rst:1507
msgid ""
"Find all the test modules by recursing into subdirectories from the "
"specified start directory, and return a TestSuite object containing them. "
"Only test files that match *pattern* will be loaded. (Using shell style "
"pattern matching.) Only module names that are importable (i.e. are valid "
"Python identifiers) will be loaded."
msgstr ""
"Trouve tous les modules de test en parcourant les sous-répertoires du "
"répertoire de démarrage spécifié, et renvoie un objet *TestSuite* qui les "
"contient. Seuls les fichiers de test qui correspondent à *pattern* sont "
"chargés. Seuls les noms de modules qui sont importables (c'est-à-dire qui "
"sont des identifiants Python valides) sont chargés."

#: ../Doc/library/unittest.rst:1513
msgid ""
"All test modules must be importable from the top level of the project. If "
"the start directory is not the top level directory then the top level "
"directory must be specified separately."
msgstr ""
"Tous les modules de test doivent être importables depuis la racine du "
"projet. Si le répertoire de démarrage n'est pas la racine, le répertoire "
"racine doit être spécifié séparément."

#: ../Doc/library/unittest.rst:1517
msgid ""
"If importing a module fails, for example due to a syntax error, then this "
"will be recorded as a single error and discovery will continue."
msgstr ""

#: ../Doc/library/unittest.rst:1520
msgid ""
"If a test package name (directory with :file:`__init__.py`) matches the "
"pattern then the package will be checked for a ``load_tests`` function. If "
"this exists then it will be called with *loader*, *tests*, *pattern*."
msgstr ""

#: ../Doc/library/unittest.rst:1525
msgid ""
"If load_tests exists then discovery does *not* recurse into the package, "
"``load_tests`` is responsible for loading all tests in the package."
msgstr ""

#: ../Doc/library/unittest.rst:1528
msgid ""
"The pattern is deliberately not stored as a loader attribute so that "
"packages can continue discovery themselves. *top_level_dir* is stored so "
"``load_tests`` does not need to pass this argument in to ``loader."
"discover()``."
msgstr ""
"Le motif n'est délibérément pas stocké en tant qu'attribut du chargeur afin "
"que les paquets puissent continuer à être découverts eux-mêmes. "
"*top_level_dir* est stocké de sorte que ``load_tests`` n'a pas besoin de "
"passer cet argument a ``loader. discover()``."

#: ../Doc/library/unittest.rst:1533
msgid "*start_dir* can be a dotted module name as well as a directory."
msgstr "*start_dir* peut être un nom de module ainsi qu'un répertoire."

#: ../Doc/library/unittest.rst:1537
msgid ""
"The following attributes of a :class:`TestLoader` can be configured either "
"by subclassing or assignment on an instance:"
msgstr ""
"Les attributs suivants d'une classe :class:`TestLoader` peuvent être "
"configurés soit par héritage, soit par affectation sur une instance  ::"

#: ../Doc/library/unittest.rst:1543
msgid ""
"String giving the prefix of method names which will be interpreted as test "
"methods.  The default value is ``'test'``."
msgstr ""
"Chaîne donnant le préfixe des noms de méthodes qui seront interprétés comme "
"méthodes de test. La valeur par défaut est ``'test'``."

#: ../Doc/library/unittest.rst:1546
msgid ""
"This affects :meth:`getTestCaseNames` and all the :meth:`loadTestsFrom\\*` "
"methods."
msgstr ""
"Ceci affecte les méthodes :meth:`getTestCaseNames` et toutes les méthodes :"
"meth:`loadTestsFrom\\*`."

#: ../Doc/library/unittest.rst:1552
msgid ""
"Function to be used to compare method names when sorting them in :meth:"
"`getTestCaseNames` and all the :meth:`loadTestsFrom\\*` methods. The default "
"value is the built-in :func:`cmp` function; the attribute can also be set "
"to :const:`None` to disable the sort."
msgstr ""

#: ../Doc/library/unittest.rst:1560
msgid ""
"Callable object that constructs a test suite from a list of tests. No "
"methods on the resulting object are needed.  The default value is the :class:"
"`TestSuite` class."
msgstr ""
"Objet appelable qui construit une suite de tests à partir d'une liste de "
"tests. Aucune méthode sur l'objet résultant n'est nécessaire.  La valeur par "
"défaut est la classe :class:`TestSuite`."

#: ../Doc/library/unittest.rst:1564
msgid "This affects all the :meth:`loadTestsFrom\\*` methods."
msgstr "Cela affecte toutes les méthodes :meth:`loadTestsFrom\\*`."

#: ../Doc/library/unittest.rst:1569
msgid ""
"This class is used to compile information about which tests have succeeded "
"and which have failed."
msgstr ""
"Cette classe est utilisée pour compiler des informations sur les tests qui "
"ont réussi et ceux qui ont échoué."

#: ../Doc/library/unittest.rst:1572
msgid ""
"A :class:`TestResult` object stores the results of a set of tests.  The :"
"class:`TestCase` and :class:`TestSuite` classes ensure that results are "
"properly recorded; test authors do not need to worry about recording the "
"outcome of tests."
msgstr ""
"Un objet :class:`TestResult` stocke les résultats d'un ensemble de tests. "
"Les classes :class:`TestCase` et :class:`TestSuite` s'assurent que les "
"résultats sont correctement enregistrés. Les auteurs du test n'ont pas à se "
"soucier de l'enregistrement des résultats des tests."

#: ../Doc/library/unittest.rst:1577
msgid ""
"Testing frameworks built on top of :mod:`unittest` may want access to the :"
"class:`TestResult` object generated by running a set of tests for reporting "
"purposes; a :class:`TestResult` instance is returned by the :meth:"
"`TestRunner.run` method for this purpose."
msgstr ""
"Les cadriciels de test construits sur :mod:`unittest` peuvent nécessiter "
"l'accès à l'objet :class:`TestResult` généré en exécutant un ensemble de "
"tests à des fins de génération de comptes-rendu. Une instance de :class:"
"`TestResult` est alors renvoyée par la méthode :meth:`TestRunner.run` à "
"cette fin."

#: ../Doc/library/unittest.rst:1582
msgid ""
":class:`TestResult` instances have the following attributes that will be of "
"interest when inspecting the results of running a set of tests:"
msgstr ""
"Les instance de :class:`TestResult` ont les attributs suivants qui sont "
"intéressant pour l'inspection des résultats de l'exécution d'un ensemble de "
"tests  ::"

#: ../Doc/library/unittest.rst:1588
msgid ""
"A list containing 2-tuples of :class:`TestCase` instances and strings "
"holding formatted tracebacks. Each tuple represents a test which raised an "
"unexpected exception."
msgstr ""
"Une liste contenant un couple d'instances de :class:`TestCase` et une "
"chaînes de caractères contenant des traces formatées. Chaque couple "
"représente un test qui a levé une exception inattendue."

#: ../Doc/library/unittest.rst:1592 ../Doc/library/unittest.rst:1602
msgid "Contains formatted tracebacks instead of :func:`sys.exc_info` results."
msgstr ""

#: ../Doc/library/unittest.rst:1598
msgid ""
"A list containing 2-tuples of :class:`TestCase` instances and strings "
"holding formatted tracebacks. Each tuple represents a test where a failure "
"was explicitly signalled using the :meth:`TestCase.assert\\*` methods."
msgstr ""
"Une liste contenant un couple d'instances de :class:`TestCase` et une "
"chaînes de caractères contenant des traces formatées. Chaque tuple "
"représente un test où un échec a été explicitement signalé en utilisant les "
"méthodes :meth:`TestCase.assert\\*`."

#: ../Doc/library/unittest.rst:1607
msgid ""
"A list containing 2-tuples of :class:`TestCase` instances and strings "
"holding the reason for skipping the test."
msgstr ""
"Une liste contenant un couple d'instances de :class:`TestCase` et une "
"chaînes de caractères contenant la raison de l'omission du test."

#: ../Doc/library/unittest.rst:1614
msgid ""
"A list containing 2-tuples of :class:`TestCase` instances and strings "
"holding formatted tracebacks.  Each tuple represents an expected failure of "
"the test case."
msgstr ""
"Une liste contenant un couple d'instance :class:`TestCase` et une chaînes de "
"caractères contenant des traces formatées. Chaque coulpe représente un échec "
"attendu du scénario de test."

#: ../Doc/library/unittest.rst:1620
msgid ""
"A list containing :class:`TestCase` instances that were marked as expected "
"failures, but succeeded."
msgstr ""
"Une liste contenant les instances :class:`TestCase` qui ont été marquées "
"comme des échecs attendus, mais qui ont réussi."

#: ../Doc/library/unittest.rst:1625
msgid ""
"Set to ``True`` when the execution of tests should stop by :meth:`stop`."
msgstr ""
"A positionner sur ``True`` quand l'exécution des tests doit être arrêter "
"par :meth:`stop`."

#: ../Doc/library/unittest.rst:1630
msgid "The total number of tests run so far."
msgstr "Le nombre total de tests effectués jusqu'à présent."

#: ../Doc/library/unittest.rst:1635
msgid ""
"If set to true, ``sys.stdout`` and ``sys.stderr`` will be buffered in "
"between :meth:`startTest` and :meth:`stopTest` being called. Collected "
"output will only be echoed onto the real ``sys.stdout`` and ``sys.stderr`` "
"if the test fails or errors. Any output is also attached to the failure / "
"error message."
msgstr ""
"S'il est défini sur *true*, ``sys.stdout`` et ``sys.stderr`` sont mis dans "
"un tampon entre les appels de :meth:`startTest` et :meth:`stopTest`. La "
"sortie collectée est répercutée sur les sorties ``sys.stdout`` et ``sys."
"stderr`` réels uniquement en cas d'échec ou d'erreur du test. Toute sortie "
"est également attachée au message d'erreur."

#: ../Doc/library/unittest.rst:1645
msgid ""
"If set to true :meth:`stop` will be called on the first failure or error, "
"halting the test run."
msgstr ""
"Si la valeur est *true* :meth:`stop` est appelée lors de la première "
"défaillance ou erreur, ce qui interrompt le test en cours d'exécution."

#: ../Doc/library/unittest.rst:1653
msgid ""
"Return ``True`` if all tests run so far have passed, otherwise returns "
"``False``."
msgstr ""
"Renvoie ``True`` si tous les tests effectués jusqu'à présent ont réussi, "
"sinon renvoie ``False``."

#: ../Doc/library/unittest.rst:1659
msgid ""
"This method can be called to signal that the set of tests being run should "
"be aborted by setting the :attr:`shouldStop` attribute to ``True``. :class:"
"`TestRunner` objects should respect this flag and return without running any "
"additional tests."
msgstr ""
"Cette méthode peut être appelée pour signaler que l'ensemble des tests en "
"cours d'exécution doit être annulé en définissant l'attribut :attr:"
"`shouldStop` sur ``True``. Les instances de :class:`TestRunner` doivent "
"respecter ce signal et se terminer sans exécuter de tests supplémentaires."

#: ../Doc/library/unittest.rst:1664
msgid ""
"For example, this feature is used by the :class:`TextTestRunner` class to "
"stop the test framework when the user signals an interrupt from the "
"keyboard.  Interactive tools which provide :class:`TestRunner` "
"implementations can use this in a similar manner."
msgstr ""
"Par exemple, cette fonctionnalité est utilisée par la classe :class:"
"`TextTestRunner` pour arrêter le cadriciel de test lorsque l'utilisateur "
"lance une interruption clavier. Les outils interactifs qui fournissent des "
"implémentations de :class:`TestRunner` peuvent l'utiliser de la même manière."

#: ../Doc/library/unittest.rst:1669
msgid ""
"The following methods of the :class:`TestResult` class are used to maintain "
"the internal data structures, and may be extended in subclasses to support "
"additional reporting requirements.  This is particularly useful in building "
"tools which support interactive reporting while tests are being run."
msgstr ""
"Les méthodes suivantes de la classe :class:`TestResult` sont utilisées pour "
"maintenir les structures de données internes, et peuvent être étendues dans "
"des sous-classes pour gérer des exigences supplémentaires en termes de "
"compte-rendu.  Cette fonction est particulièrement utile pour créer des "
"outils qui prennent en charge la génération de rapports interactifs pendant "
"l'exécution des tests."

#: ../Doc/library/unittest.rst:1677
msgid "Called when the test case *test* is about to be run."
msgstr ""
"Appelé lorsque le scénario de test *test* est sur le point d'être exécuté."

#: ../Doc/library/unittest.rst:1681
msgid ""
"Called after the test case *test* has been executed, regardless of the "
"outcome."
msgstr ""
"Appelé après l'exécution du cas de test *test*, quel qu'en soit le résultat."

#: ../Doc/library/unittest.rst:1686
msgid "Called once before any tests are executed."
msgstr "Appelé une fois avant l'exécution des tests."

#: ../Doc/library/unittest.rst:1693
msgid "Called once after all tests are executed."
msgstr "Appelé une fois après l'exécution des tests."

#: ../Doc/library/unittest.rst:1700
msgid ""
"Called when the test case *test* raises an unexpected exception. *err* is a "
"tuple of the form returned by :func:`sys.exc_info`: ``(type, value, "
"traceback)``."
msgstr ""
"Appelé lorsque le cas de test *test* soulève une exception inattendue. *err* "
"est un couple du formulaire renvoyé par :func:`sys.exc_info` : ``(type, "
"valeur, traceback)``."

#: ../Doc/library/unittest.rst:1704
msgid ""
"The default implementation appends a tuple ``(test, formatted_err)`` to the "
"instance's :attr:`errors` attribute, where *formatted_err* is a formatted "
"traceback derived from *err*."
msgstr ""
"L'implémentation par défaut ajoute un couple ``(test, formatted_err)`` à "
"l'attribut :attr:`errors` de l'instance, où *formatted_err* est une trace "
"formatée à partir de *err*."

#: ../Doc/library/unittest.rst:1711
msgid ""
"Called when the test case *test* signals a failure. *err* is a tuple of the "
"form returned by :func:`sys.exc_info`: ``(type, value, traceback)``."
msgstr ""
"Appelé lorsque le cas de test *test* soulève une exception inattendue. *err* "
"est un triplet de la même forme que celui renvoyé par :func:`sys.exc_info` : "
"``(type, valeur, traceback)``."

#: ../Doc/library/unittest.rst:1714
msgid ""
"The default implementation appends a tuple ``(test, formatted_err)`` to the "
"instance's :attr:`failures` attribute, where *formatted_err* is a formatted "
"traceback derived from *err*."
msgstr ""
"L'implémentation par défaut ajoute un couple ``(test, formatted_err)`` à "
"l'attribut :attr:`errors` de l'instance, où *formatted_err* est une trace "
"formatée à partir de *err*."

#: ../Doc/library/unittest.rst:1721
msgid "Called when the test case *test* succeeds."
msgstr "Appelé lorsque le scénario de test *test* réussit."

#: ../Doc/library/unittest.rst:1723
msgid "The default implementation does nothing."
msgstr "L'implémentation par défaut ne fait rien."

#: ../Doc/library/unittest.rst:1728
msgid ""
"Called when the test case *test* is skipped.  *reason* is the reason the "
"test gave for skipping."
msgstr ""
"Appelé lorsque le scénario de test *test* est ignoré. *raison* est la raison "
"pour laquelle le test donné à été ignoré."

#: ../Doc/library/unittest.rst:1731
msgid ""
"The default implementation appends a tuple ``(test, reason)`` to the "
"instance's :attr:`skipped` attribute."
msgstr ""
"L'implémentation par défaut ajoute un couple ``(test, raison)`` à "
"l'attribut :attr:`skipped` de l'instance."

#: ../Doc/library/unittest.rst:1737
msgid ""
"Called when the test case *test* fails, but was marked with the :func:"
"`expectedFailure` decorator."
msgstr ""
"Appelé lorsque le scénario de test *test* échoue, mais qui a été marqué avec "
"le décorateur :func:`expectedFailure`."

#: ../Doc/library/unittest.rst:1740
msgid ""
"The default implementation appends a tuple ``(test, formatted_err)`` to the "
"instance's :attr:`expectedFailures` attribute, where *formatted_err* is a "
"formatted traceback derived from *err*."
msgstr ""
"L'implémentation par défaut ajoute un couple ``(test, formatted_err)`` à "
"l'attribut :attr:`errors` de l'instance, où *formatted_err* est une trace "
"formatée à partir de *err*."

#: ../Doc/library/unittest.rst:1747
msgid ""
"Called when the test case *test* was marked with the :func:`expectedFailure` "
"decorator, but succeeded."
msgstr ""
"Appelé lorsque le scénario de test *test* réussit, mais que ce scénario a "
"été marqué avec le décorateur :func:`expectedFailure`."

#: ../Doc/library/unittest.rst:1750
msgid ""
"The default implementation appends the test to the instance's :attr:"
"`unexpectedSuccesses` attribute."
msgstr ""
"L'implémentation par défaut ajoute le test à l'attribut :attr:"
"`unexpectedSuccesses` de l'instance."

#: ../Doc/library/unittest.rst:1755
msgid ""
"A concrete implementation of :class:`TestResult` used by the :class:"
"`TextTestRunner`."
msgstr ""
"Une implémentation concrète de :class:`TestResult` utilisé par la classe :"
"class:`TextTestRunner`."

#: ../Doc/library/unittest.rst:1758
msgid ""
"This class was previously named ``_TextTestResult``. The old name still "
"exists as an alias but is deprecated."
msgstr ""
"Cette classe s'appelait auparavant ``_TextTestResult``. L'ancien nom existe "
"toujours en tant qu'alias, mais il est obsolète."

#: ../Doc/library/unittest.rst:1764
msgid ""
"Instance of the :class:`TestLoader` class intended to be shared.  If no "
"customization of the :class:`TestLoader` is needed, this instance can be "
"used instead of repeatedly creating new instances."
msgstr ""
"Instance de la classe :class:`TestLoader` destinée à être partagée. Si "
"aucune personnalisation de la classe :class:`TestLoader` n'est nécessaire, "
"cette instance peut être utilisée au lieu de créer plusieurs fois de "
"nouvelles instances."

#: ../Doc/library/unittest.rst:1772
msgid ""
"A basic test runner implementation which prints results on standard error. "
"It has a few configurable parameters, but is essentially very simple.  "
"Graphical applications which run test suites should provide alternate "
"implementations."
msgstr ""

#: ../Doc/library/unittest.rst:1778
msgid ""
"This method returns the instance of ``TestResult`` used by :meth:`run`. It "
"is not intended to be called directly, but can be overridden in subclasses "
"to provide a custom ``TestResult``."
msgstr ""
"Cette méthode renvoie l'instance de ``TestResult`` utilisée par :meth:`run`. "
"Il n'est pas destiné à être appelé directement, mais peut être surchargée "
"dans des sous-classes pour fournir un ``TestResult`` personnalisé."

#: ../Doc/library/unittest.rst:1782
msgid ""
"``_makeResult()`` instantiates the class or callable passed in the "
"``TextTestRunner`` constructor as the ``resultclass`` argument. It defaults "
"to :class:`TextTestResult` if no ``resultclass`` is provided. The result "
"class is instantiated with the following arguments::"
msgstr ""
"``_makeResult()`` instancie la classe ou l'appelable passé dans le "
"constructeur ``TextTestRunner`` comme argument ``resultclass``. Il vaut par "
"défaut :class:`TextTestResult` si aucune ``resultclass`` n'est fournie. La "
"classe de résultat est instanciée avec les arguments suivants  ::"

#: ../Doc/library/unittest.rst:1792
msgid ""
"A command-line program that loads a set of tests from *module* and runs "
"them; this is primarily for making test modules conveniently executable. The "
"simplest use for this function is to include the following line at the end "
"of a test script::"
msgstr ""
"Un programme en ligne de commande qui charge un ensemble de tests à partir "
"du *module* et les exécute. L'utilisation principale est de rendre les "
"modules de test facilement exécutables. L'utilisation la plus simple pour "
"cette fonction est d'inclure la ligne suivante à la fin d'un script de test "
" ::"

#: ../Doc/library/unittest.rst:1800
msgid ""
"You can run tests with more detailed information by passing in the verbosity "
"argument::"
msgstr ""
"Vous pouvez exécuter des tests avec des informations plus détaillées en "
"utilisant l'option de verbosité  ::"

#: ../Doc/library/unittest.rst:1806
msgid ""
"The *defaultTest* argument is the name of the test to run if no test names "
"are specified via *argv*.  If not specified or ``None`` and no test names "
"are provided via *argv*, all tests found in *module* are run."
msgstr ""

#: ../Doc/library/unittest.rst:1810
msgid ""
"The *argv* argument can be a list of options passed to the program, with the "
"first element being the program name.  If not specified or ``None``, the "
"values of :data:`sys.argv` are used."
msgstr ""
"L'argument *argv* peut être une liste d'options passées au programme, le "
"premier élément étant le nom du programme. S'il n'est pas spécifié ou vaut "
"``None``, les valeurs de :data:`sys.argv` sont utilisées."

#: ../Doc/library/unittest.rst:1814
msgid ""
"The *testRunner* argument can either be a test runner class or an already "
"created instance of it. By default ``main`` calls :func:`sys.exit` with an "
"exit code indicating success or failure of the tests run."
msgstr ""
"L'argument *testRunner* peut être soit une classe de lanceur de test, soit "
"une instance déjà créée de celle-ci. Par défaut, ``main`` appelle :func:`sys."
"exit` avec un code de sortie indiquant le succès ou l'échec des tests "
"exécutés."

#: ../Doc/library/unittest.rst:1818
msgid ""
"The *testLoader* argument has to be a :class:`TestLoader` instance, and "
"defaults to :data:`defaultTestLoader`."
msgstr ""
"L'argument *testLoader* doit être une instance de :class:`TestLoader`, et "
"par défaut de :data:`defaultTestLoader`."

#: ../Doc/library/unittest.rst:1821
msgid ""
"``main`` supports being used from the interactive interpreter by passing in "
"the argument ``exit=False``. This displays the result on standard output "
"without calling :func:`sys.exit`::"
msgstr ""
"Les ``main`` sont utilisés à partir de l'interpréteur interactif en passant "
"dans l'argument ``exit=False``. Ceci affiche le résultat sur la sortie "
"standard sans appeler :func:`sys.exit`  ::"

#: ../Doc/library/unittest.rst:1828
msgid ""
"The *failfast*, *catchbreak* and *buffer* parameters have the same effect as "
"the same-name `command-line options`_."
msgstr ""
"Les paramètres *failfast*, *catchbreak* et *buffer* ont le même effet que la "
"même option en ligne de commande `command-line options`_."

#: ../Doc/library/unittest.rst:1831
msgid ""
"Calling ``main`` actually returns an instance of the ``TestProgram`` class. "
"This stores the result of the tests run as the ``result`` attribute."
msgstr ""
"L'appel de ``main`` renvoie en fait une instance de la classe "
"``TestProgram``. Le résultat des tests effectués est enregistré sous "
"l'attribut ``result``."

#: ../Doc/library/unittest.rst:1834
msgid ""
"The *exit*, *verbosity*, *failfast*, *catchbreak* and *buffer* parameters "
"were added."
msgstr ""

#: ../Doc/library/unittest.rst:1840
msgid "load_tests Protocol"
msgstr "Protocole de chargement des tests (*load_tests Protocol*)"

#: ../Doc/library/unittest.rst:1844
msgid ""
"Modules or packages can customize how tests are loaded from them during "
"normal test runs or test discovery by implementing a function called "
"``load_tests``."
msgstr ""
"Les modules ou paquets peuvent personnaliser la façon dont les tests sont "
"chargés à partir de ceux-ci pendant l'exécution des tests ou pendant la "
"découverte de tests en implémentant une fonction appelée ``load_tests``."

#: ../Doc/library/unittest.rst:1847
msgid ""
"If a test module defines ``load_tests`` it will be called by :meth:"
"`TestLoader.loadTestsFromModule` with the following arguments::"
msgstr ""
"Si un module de test définit ``load_tests`` il est appelé par :meth:"
"`TestLoader.loadTestsFromModule` avec les arguments suivants  ::"

#: ../Doc/library/unittest.rst:1852
msgid "It should return a :class:`TestSuite`."
msgstr "Elle doit renvoyer une classe :class:`TestSuite`."

#: ../Doc/library/unittest.rst:1854
msgid ""
"*loader* is the instance of :class:`TestLoader` doing the loading. "
"*standard_tests* are the tests that would be loaded by default from the "
"module. It is common for test modules to only want to add or remove tests "
"from the standard set of tests. The third argument is used when loading "
"packages as part of test discovery."
msgstr ""
"*loader* est l'instance de :class:`TestLoader` qui effectue le chargement. "
"*standard_tests* sont les tests qui sont chargés par défaut depuis le "
"module. Il est courant que les modules de test veuillent seulement ajouter "
"ou supprimer des tests de l'ensemble standard de tests. Le troisième "
"argument est utilisé lors du chargement de paquets dans le cadre de la "
"découverte de tests."

#: ../Doc/library/unittest.rst:1860
msgid ""
"A typical ``load_tests`` function that loads tests from a specific set of :"
"class:`TestCase` classes may look like::"
msgstr ""
"Une fonction typique de ``load_tests`` qui charge les tests d'un ensemble "
"spécifique de classes :class:`TestCase` peut ressembler à  ::"

#: ../Doc/library/unittest.rst:1872
msgid ""
"If discovery is started, either from the command line or by calling :meth:"
"`TestLoader.discover`, with a pattern that matches a package name then the "
"package :file:`__init__.py` will be checked for ``load_tests``."
msgstr ""

#: ../Doc/library/unittest.rst:1878
msgid ""
"The default pattern is ``'test*.py'``. This matches all Python files that "
"start with ``'test'`` but *won't* match any test directories."
msgstr ""

#: ../Doc/library/unittest.rst:1881
msgid "A pattern like ``'test*'`` will match test packages as well as modules."
msgstr ""

#: ../Doc/library/unittest.rst:1884
msgid ""
"If the package :file:`__init__.py` defines ``load_tests`` then it will be "
"called and discovery not continued into the package. ``load_tests`` is "
"called with the following arguments::"
msgstr ""

#: ../Doc/library/unittest.rst:1890
msgid ""
"This should return a :class:`TestSuite` representing all the tests from the "
"package. (``standard_tests`` will only contain tests collected from :file:"
"`__init__.py`.)"
msgstr ""
"Doit retourner une classe :class:`TestSuite` représentant tous les tests du "
"paquet. (``standard_tests`` ne contient que les tests collectés dans le "
"fichier :file:`__init__.py`)."

#: ../Doc/library/unittest.rst:1894
msgid ""
"Because the pattern is passed into ``load_tests`` the package is free to "
"continue (and potentially modify) test discovery. A 'do nothing' "
"``load_tests`` function for a test package would look like::"
msgstr ""
"Comme le motif est passé à ``load_tests``, le paquet est libre de continuer "
"(et potentiellement de modifier) la découverte des tests. Une fonction « ne "
"rien faire » ``load_tests`` pour un paquet de test ressemblerait à  ::"

#: ../Doc/library/unittest.rst:1907
msgid "Class and Module Fixtures"
msgstr "Classes et modules d'aménagements des tests"

#: ../Doc/library/unittest.rst:1909
msgid ""
"Class and module level fixtures are implemented in :class:`TestSuite`. When "
"the test suite encounters a test from a new class then :meth:`tearDownClass` "
"from the previous class (if there is one) is called, followed by :meth:"
"`setUpClass` from the new class."
msgstr ""
"Les classes et modules d'aménagements des tests sont implémentés dans :class:"
"`TestSuite`. Lorsque la suite de tests rencontre un test d'une nouvelle "
"classe, alors :meth:`tearDownClass` de la classe précédente (s'il y en a "
"une) est appelé, suivi de :meth:`setUpClass` de la nouvelle classe."

#: ../Doc/library/unittest.rst:1914
msgid ""
"Similarly if a test is from a different module from the previous test then "
"``tearDownModule`` from the previous module is run, followed by "
"``setUpModule`` from the new module."
msgstr ""
"De même, si un test provient d'un module différent du test précédent, alors "
"``tearDownModule`` du module précédent est exécuté, suivi par "
"``setUpModule`` du nouveau module."

#: ../Doc/library/unittest.rst:1918
msgid ""
"After all the tests have run the final ``tearDownClass`` and "
"``tearDownModule`` are run."
msgstr ""
"Après que tous les tests ont été exécutés, les ``tearDownClass`` et "
"``tearDownModule`` finaux sont exécutés."

#: ../Doc/library/unittest.rst:1921
msgid ""
"Note that shared fixtures do not play well with [potential] features like "
"test parallelization and they break test isolation. They should be used with "
"care."
msgstr ""
"Notez que les aménagements de tests partagés ne fonctionnent pas bien avec "
"de « potentielles » fonctions comme la parallélisation de test et qu'ils "
"brisent l'isolation des tests. Ils doivent être utilisés avec parcimonie."

#: ../Doc/library/unittest.rst:1924
msgid ""
"The default ordering of tests created by the unittest test loaders is to "
"group all tests from the same modules and classes together. This will lead "
"to ``setUpClass`` / ``setUpModule`` (etc) being called exactly once per "
"class and module. If you randomize the order, so that tests from different "
"modules and classes are adjacent to each other, then these shared fixture "
"functions may be called multiple times in a single test run."
msgstr ""
"L'ordre par défaut des tests créés par les chargeurs de tests unitaires est "
"de regrouper tous les tests des mêmes modules et classes. Cela à pour "
"conséquence que ``setUpClass`` / ``setUpModule`` (etc) sont appelé "
"exactement une fois par classe et module. Si vous rendez l'ordre aléatoire, "
"de sorte que les tests de différents modules et classes soient adjacents les "
"uns aux autres, alors ces fonctions d'aménagements partagées peuvent être "
"appelées plusieurs fois dans un même test."

#: ../Doc/library/unittest.rst:1931
msgid ""
"Shared fixtures are not intended to work with suites with non-standard "
"ordering. A ``BaseTestSuite`` still exists for frameworks that don't want to "
"support shared fixtures."
msgstr ""
"Les aménagements de tests partagés ne sont pas conçus pour fonctionner avec "
"des suites dont la commande n'est pas standard. Une ``BaseTestSuite`` existe "
"toujours pour les cadriciels qui ne veulent pas gérer les aménagements de "
"tests partagés."

#: ../Doc/library/unittest.rst:1935
msgid ""
"If there are any exceptions raised during one of the shared fixture "
"functions the test is reported as an error. Because there is no "
"corresponding test instance an ``_ErrorHolder`` object (that has the same "
"interface as a :class:`TestCase`) is created to represent the error. If you "
"are just using the standard unittest test runner then this detail doesn't "
"matter, but if you are a framework author it may be relevant."
msgstr ""
"S'il y a des exceptions levées pendant l'une des fonctions d'aménagement de "
"tests partagés, le test est signalé comme étant en erreur. Parce qu'il n'y a "
"pas d'instance de test correspondante, un objet ``_ErrorHolder`` (qui a la "
"même interface qu'une classe :class:`TestCase`) est créé pour représenter "
"l'erreur. Si vous n'utilisez que le lanceur de test unitaire standard, ce "
"détail n'a pas d'importance, mais si vous êtes un auteur de cadriciel de "
"test, il peut être pertinent."

#: ../Doc/library/unittest.rst:1944
msgid "setUpClass and tearDownClass"
msgstr ""
"Classes de mise en place (*setUpClass*) et de démantèlement des tests "
"(*tearDownClass*)"

#: ../Doc/library/unittest.rst:1946
msgid "These must be implemented as class methods::"
msgstr "Elles doivent être implémentées en tant que méthodes de classe  ::"

#: ../Doc/library/unittest.rst:1959
msgid ""
"If you want the ``setUpClass`` and ``tearDownClass`` on base classes called "
"then you must call up to them yourself. The implementations in :class:"
"`TestCase` are empty."
msgstr ""
"Si vous voulez que les classes de base ``setUpClass`` et ``tearDownClass`` "
"soient appelées, vous devez les appeler vous-même. Les implémentations dans :"
"class:`TestCase` sont vides."

#: ../Doc/library/unittest.rst:1963
msgid ""
"If an exception is raised during a ``setUpClass`` then the tests in the "
"class are not run and the ``tearDownClass`` is not run. Skipped classes will "
"not have ``setUpClass`` or ``tearDownClass`` run. If the exception is a :exc:"
"`SkipTest` exception then the class will be reported as having been skipped "
"instead of as an error."
msgstr ""
"Si une exception est levée pendant l'exécution de ``setUpClass`` alors les "
"tests dans la classe ne sont pas exécutés et la classe ``tearDownClass`` "
"n'est pas exécutée. Les classes ignorées n'auront pas d'exécution de "
"``setUpClass`` ou ``tearDownClass``. Si l'exception est une exception :exc:"
"`SkipTest` alors la classe est signalée comme ayant été ignorée au lieu "
"d'être en échec."

#: ../Doc/library/unittest.rst:1971
msgid "setUpModule and tearDownModule"
msgstr ""
"Module de mise en place (*setUpModule*) et de démantèlement des tests "
"(*tearDownModule*)"

#: ../Doc/library/unittest.rst:1973
msgid "These should be implemented as functions::"
msgstr "Elles doivent être implémentées en tant que fonctions  ::"

#: ../Doc/library/unittest.rst:1981
msgid ""
"If an exception is raised in a ``setUpModule`` then none of the tests in the "
"module will be run and the ``tearDownModule`` will not be run. If the "
"exception is a :exc:`SkipTest` exception then the module will be reported as "
"having been skipped instead of as an error."
msgstr ""
"Si une exception est levée pendant l'exécution de la fonction "
"``setUpModule`` alors aucun des tests du module ne sera exécuté et la "
"fonction ``tearDownModule`` ne sera pas exécutée. Si l'exception est une "
"exception :exc:`SkipTest` alors le module est signalé comme ayant été ignoré "
"au lieu d'être en échec."

#: ../Doc/library/unittest.rst:1988
msgid "Signal Handling"
msgstr "Traitement des signaux"

#: ../Doc/library/unittest.rst:1990
msgid ""
"The :option:`-c/--catch <unittest -c>` command-line option to unittest, "
"along with the ``catchbreak`` parameter to :func:`unittest.main()`, provide "
"more friendly handling of control-C during a test run. With catch break "
"behavior enabled control-C will allow the currently running test to "
"complete, and the test run will then end and report all the results so far. "
"A second control-c will raise a :exc:`KeyboardInterrupt` in the usual way."
msgstr ""
"L'option :option:`-c/--catch <unittest -c>` en ligne de commande pour "
"*unittest*, ainsi que le paramètre ``catchbreak`` vers :func:`unittest."
"main()`, permettent une utilisation simplifiée du contrôle-C pendant un "
"test. Avec l'activation de ``catchbreak``, l'utilisation du contrôle-C "
"permet de terminer le test en cours d'exécution, et le test se termine et "
"rapporte tous les résultats obtenus jusqu'à présent. Un deuxième contrôle-C "
"lève une exception classique :exc:`KeyboardInterrupt`."

#: ../Doc/library/unittest.rst:1997
msgid ""
"The control-c handling signal handler attempts to remain compatible with "
"code or tests that install their own :const:`signal.SIGINT` handler. If the "
"``unittest`` handler is called but *isn't* the installed :const:`signal."
"SIGINT` handler, i.e. it has been replaced by the system under test and "
"delegated to, then it calls the default handler. This will normally be the "
"expected behavior by code that replaces an installed handler and delegates "
"to it. For individual tests that need ``unittest`` control-c handling "
"disabled the :func:`removeHandler` decorator can be used."
msgstr ""
"Le gestionnaire du signal *contrôle-C* tente de rester compatible avec le "
"code ou les tests qui installent leur propre gestionnaire :const:`signal."
"SIGINT`. Si le gestionnaire ``unittest`` est appelé mais *n'est pas* le "
"gestionnaire installé :const:`signal.SIGINT`, c'est-à-dire qu'il a été "
"remplacé par le système sous test et délégué, alors il appelle le "
"gestionnaire par défaut. C'est normalement le comportement attendu par un "
"code qui remplace un gestionnaire installé et lui délègue. Pour les tests "
"individuels qui ont besoin que le signal *contrôle-C* \"*unittest*\" soit "
"désactivée, le décorateur :func:`removeHandler` peut être utilisé."

#: ../Doc/library/unittest.rst:2006
msgid ""
"There are a few utility functions for framework authors to enable control-c "
"handling functionality within test frameworks."
msgstr ""
"Il existe quelques fonctions de support pour les auteurs de cadriciel afin "
"d'activer la fonctionnalité  de gestion des *contrôle-C* dans les cadriciels "
"de test."

#: ../Doc/library/unittest.rst:2011
msgid ""
"Install the control-c handler. When a :const:`signal.SIGINT` is received "
"(usually in response to the user pressing control-c) all registered results "
"have :meth:`~TestResult.stop` called."
msgstr ""
"Installe le gestionnaire *contrôle-c*. Quand un :const:`signal.SIGINT` est "
"reçu (généralement en réponse à l'utilisateur appuyant sur *contrôle-c*) "
"tous les résultats enregistrés vont appeler la méthode :meth:`~TestResult."
"stop`."

#: ../Doc/library/unittest.rst:2019
msgid ""
"Register a :class:`TestResult` object for control-c handling. Registering a "
"result stores a weak reference to it, so it doesn't prevent the result from "
"being garbage collected."
msgstr ""
"Enregistre un objet :class:`TestResult` pour la gestion du *contrôle-C*. "
"L'enregistrement d'un résultat stocke une référence faible sur celui-ci, de "
"sorte qu'il n'empêche pas que le résultat soit collecté par le ramasse-"
"miette."

#: ../Doc/library/unittest.rst:2023
msgid ""
"Registering a :class:`TestResult` object has no side-effects if control-c "
"handling is not enabled, so test frameworks can unconditionally register all "
"results they create independently of whether or not handling is enabled."
msgstr ""
"L'enregistrement d'un objet :class:`TestResult` n'a pas d'effets de bord si "
"la gestion du *contrôle-c* n'est pas activée, donc les cadriciels de test "
"peuvent enregistrer sans condition tous les résultats qu'ils créent "
"indépendamment du fait que la gestion soit activée ou non."

#: ../Doc/library/unittest.rst:2031
msgid ""
"Remove a registered result. Once a result has been removed then :meth:"
"`~TestResult.stop` will no longer be called on that result object in "
"response to a control-c."
msgstr ""
"Supprime un résultat enregistré. Une fois qu'un résultat a été supprimé, :"
"meth:`~TestResult.stop` n'est plus appelé sur cet objet résultat en réponse "
"à un *contrôle-c*."

#: ../Doc/library/unittest.rst:2039
msgid ""
"When called without arguments this function removes the control-c handler if "
"it has been installed. This function can also be used as a test decorator to "
"temporarily remove the handler whilst the test is being executed::"
msgstr ""
