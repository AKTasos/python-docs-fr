# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2016, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-10-30 10:44+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../Doc/reference/lexical_analysis.rst:6
msgid "Lexical analysis"
msgstr "Analyse lexicale"

#: ../Doc/reference/lexical_analysis.rst:13
msgid ""
"A Python program is read by a *parser*.  Input to the parser is a stream of "
"*tokens*, generated by the *lexical analyzer*.  This chapter describes how "
"the lexical analyzer breaks a file into tokens."
msgstr ""
"Un programme Python est lu par un analyseur syntaxique (*parser* en "
"anglais). En entrée de cet analyseur syntaxique, nous trouvons des lexèmes "
"(*tokens* en anglais), produits par un analyseur lexical. Ce chapitre décrit "
"comment l'analyseur lexical découpe le fichier en lexèmes."

#: ../Doc/reference/lexical_analysis.rst:17
msgid "Python uses the 7-bit ASCII character set for program text."
msgstr ""

#: ../Doc/reference/lexical_analysis.rst:19
msgid ""
"An encoding declaration can be used to indicate that  string literals and "
"comments use an encoding different from ASCII."
msgstr ""

#: ../Doc/reference/lexical_analysis.rst:23
msgid ""
"For compatibility with older versions, Python only warns if it finds 8-bit "
"characters; those warnings should be corrected by either declaring an "
"explicit encoding, or using escape sequences if those bytes are binary data, "
"instead of characters."
msgstr ""

#: ../Doc/reference/lexical_analysis.rst:28
msgid ""
"The run-time character set depends on the I/O devices connected to the "
"program but is generally a superset of ASCII."
msgstr ""

#: ../Doc/reference/lexical_analysis.rst:31
msgid ""
"**Future compatibility note:** It may be tempting to assume that the "
"character set for 8-bit characters is ISO Latin-1 (an ASCII superset that "
"covers most western languages that use the Latin alphabet), but it is "
"possible that in the future Unicode text editors will become common.  These "
"generally use the UTF-8 encoding, which is also an ASCII superset, but with "
"very different use for the characters with ordinals 128-255.  While there is "
"no consensus on this subject yet, it is unwise to assume either Latin-1 or "
"UTF-8, even though the current implementation appears to favor Latin-1.  "
"This applies both to the source character set and the run-time character set."
msgstr ""

#: ../Doc/reference/lexical_analysis.rst:45
msgid "Line structure"
msgstr "Structure des lignes"

#: ../Doc/reference/lexical_analysis.rst:49
msgid "A Python program is divided into a number of *logical lines*."
msgstr "Un programme en Python est divisé en *lignes logiques*."

#: ../Doc/reference/lexical_analysis.rst:55
msgid "Logical lines"
msgstr "Lignes logiques"

#: ../Doc/reference/lexical_analysis.rst:63
msgid ""
"The end of a logical line is represented by the token NEWLINE.  Statements "
"cannot cross logical line boundaries except where NEWLINE is allowed by the "
"syntax (e.g., between statements in compound statements). A logical line is "
"constructed from one or more *physical lines* by following the explicit or "
"implicit *line joining* rules."
msgstr ""
"La fin d'une ligne logique est représentée par le lexème NEWLINE. Les "
"instructions ne peuvent pas traverser les limites des lignes logiques, sauf "
"quand NEWLINE est autorisé par la syntaxe (par exemple, entre les "
"instructions des instructions composées). Une ligne logique est constituée "
"d'une ou plusieurs *lignes physiques* en fonction des règles, explicites ou "
"implicites, de *continuation de ligne*."

#: ../Doc/reference/lexical_analysis.rst:73
msgid "Physical lines"
msgstr "Lignes physiques"

#: ../Doc/reference/lexical_analysis.rst:75
msgid ""
"A physical line is a sequence of characters terminated by an end-of-line "
"sequence.  In source files, any of the standard platform line termination "
"sequences can be used - the Unix form using ASCII LF (linefeed), the Windows "
"form using the ASCII sequence CR LF (return followed by linefeed), or the "
"old Macintosh form using the ASCII CR (return) character.  All of these "
"forms can be used equally, regardless of platform."
msgstr ""

#: ../Doc/reference/lexical_analysis.rst:82
msgid ""
"When embedding Python, source code strings should be passed to Python APIs "
"using the standard C conventions for newline characters (the ``\\n`` "
"character, representing ASCII LF, is the line terminator)."
msgstr ""
"Lorsque vous encapsulez Python, les chaînes de code source doivent être "
"passées à l'API Python en utilisant les conventions du C standard pour les "
"caractères de fin de ligne : le caractère ``\\n``, dont le code ASCII est LF."

#: ../Doc/reference/lexical_analysis.rst:90
msgid "Comments"
msgstr "Commentaires"

#: ../Doc/reference/lexical_analysis.rst:96
msgid ""
"A comment starts with a hash character (``#``) that is not part of a string "
"literal, and ends at the end of the physical line.  A comment signifies the "
"end of the logical line unless the implicit line joining rules are invoked. "
"Comments are ignored by the syntax; they are not tokens."
msgstr ""
"Un commentaire commence par le caractère croisillon (``#``, *hash* en "
"anglais et qui ressemble au symbole musical dièse, c'est pourquoi il est "
"souvent improprement appelé caractère dièse) situé en dehors d'une chaine de "
"caractères littérale et se termine à la fin de la ligne physique. Un "
"commentaire signifie la fin de la ligne logique à moins qu'une règle de "
"continuation de ligne implicite ne s'applique. Les commentaires sont ignorés "
"au niveau syntaxique, ce ne sont pas des lexèmes."

#: ../Doc/reference/lexical_analysis.rst:105
msgid "Encoding declarations"
msgstr "Déclaration d'encodage"

#: ../Doc/reference/lexical_analysis.rst:109
msgid ""
"If a comment in the first or second line of the Python script matches the "
"regular expression ``coding[=:]\\s*([-\\w.]+)``, this comment is processed "
"as an encoding declaration; the first group of this expression names the "
"encoding of the source code file. The encoding declaration must appear on a "
"line of its own. If it is the second line, the first line must also be a "
"comment-only line. The recommended forms of an encoding expression are ::"
msgstr ""
"Si un commentaire placé sur la première ou deuxième ligne du script Python "
"correspond à l'expression rationnelle ``coding[=:]\\s*([-\\w.]+)``, ce "
"commentaire est analysé comme une déclaration d'encodage ; le premier groupe "
"de cette expression désigne l'encodage du fichier source. Cette déclaration "
"d'encodage doit être seule sur sa ligne et, si elle est sur la deuxième "
"ligne, la première ligne doit aussi être une ligne composée uniquement d'un "
"commentaire. Les formes recommandées pour l'expression de l'encodage sont ::"

#: ../Doc/reference/lexical_analysis.rst:118
msgid "which is recognized also by GNU Emacs, and ::"
msgstr "qui est reconnue aussi par GNU Emacs et ::"

#: ../Doc/reference/lexical_analysis.rst:122
msgid ""
"which is recognized by Bram Moolenaar's VIM. In addition, if the first bytes "
"of the file are the UTF-8 byte-order mark (``'\\xef\\xbb\\xbf'``), the "
"declared file encoding is UTF-8 (this is supported, among others, by "
"Microsoft's :program:`notepad`)."
msgstr ""

#: ../Doc/reference/lexical_analysis.rst:127
msgid ""
"If an encoding is declared, the encoding name must be recognized by Python. "
"The encoding is used for all lexical analysis, in particular to find the end "
"of a string, and to interpret the contents of Unicode literals. String "
"literals are converted to Unicode for syntactical analysis, then converted "
"back to their original encoding before interpretation starts."
msgstr ""

#: ../Doc/reference/lexical_analysis.rst:139
msgid "Explicit line joining"
msgstr "Continuation de ligne explicite"

#: ../Doc/reference/lexical_analysis.rst:147
msgid ""
"Two or more physical lines may be joined into logical lines using backslash "
"characters (``\\``), as follows: when a physical line ends in a backslash "
"that is not part of a string literal or comment, it is joined with the "
"following forming a single logical line, deleting the backslash and the "
"following end-of-line character.  For example::"
msgstr ""
"Deux lignes physiques, ou plus, peuvent être jointes pour former une seule "
"ligne logique en utilisant la barre oblique inversée (``\\``) selon la règle "
"suivante : quand la ligne physique se termine par une barre oblique inversée "
"qui ne fait pas partie d'une chaine de caractères ou d'un commentaire, la "
"ligne immédiatement suivante lui est adjointe pour former une seule ligne "
"logique, en supprimant la barre oblique inversée et le caractère de fin de "
"ligne. Par exemple ::"

#: ../Doc/reference/lexical_analysis.rst:158
msgid ""
"A line ending in a backslash cannot carry a comment.  A backslash does not "
"continue a comment.  A backslash does not continue a token except for string "
"literals (i.e., tokens other than string literals cannot be split across "
"physical lines using a backslash).  A backslash is illegal elsewhere on a "
"line outside a string literal."
msgstr ""
"Une ligne que se termine par une barre oblique inversée ne peut pas avoir de "
"commentaire. La barre oblique inversée ne permet pas de continuer un "
"commentaire. La barre oblique inversée ne permet pas de continuer un lexème, "
"sauf s'il s'agit d'une chaîne de caractères (par exemple, les lexèmes autres "
"que les chaînes de caractères ne peuvent pas être répartis sur plusieurs "
"lignes en utilisant une barre oblique inversée). La barre oblique inversée "
"n'est pas autorisée ailleurs sur la ligne, en dehors d'une chaîne de "
"caractères."

#: ../Doc/reference/lexical_analysis.rst:168
msgid "Implicit line joining"
msgstr "Continuation de ligne implicite"

#: ../Doc/reference/lexical_analysis.rst:170
msgid ""
"Expressions in parentheses, square brackets or curly braces can be split "
"over more than one physical line without using backslashes. For example::"
msgstr ""
"Les expressions entre parenthèses, crochets ou accolades peuvent être "
"réparties sur plusieurs lignes sans utiliser de barre oblique inversée. Par "
"exemple ::"

#: ../Doc/reference/lexical_analysis.rst:178
msgid ""
"Implicitly continued lines can carry comments.  The indentation of the "
"continuation lines is not important.  Blank continuation lines are allowed. "
"There is no NEWLINE token between implicit continuation lines.  Implicitly "
"continued lines can also occur within triple-quoted strings (see below); in "
"that case they cannot carry comments."
msgstr ""
"Les lignes continuées implicitement peuvent avoir des commentaires. "
"L'indentation des lignes de continuation n'est pas importante. Une ligne "
"blanche est autorisée comme ligne de continuation. Il ne doit pas y avoir de "
"lexème NEWLINE entre des lignes implicitement continuées. Les lignes "
"continuées implicitement peuvent être utilisées dans des chaînes entre "
"triples guillemets (voir ci-dessous) ; dans ce cas, elles ne peuvent pas "
"avoir de commentaires."

#: ../Doc/reference/lexical_analysis.rst:188
msgid "Blank lines"
msgstr "Lignes vierges"

#: ../Doc/reference/lexical_analysis.rst:192
msgid ""
"A logical line that contains only spaces, tabs, formfeeds and possibly a "
"comment, is ignored (i.e., no NEWLINE token is generated).  During "
"interactive input of statements, handling of a blank line may differ "
"depending on the implementation of the read-eval-print loop.  In the "
"standard implementation, an entirely blank logical line (i.e. one containing "
"not even whitespace or a comment) terminates a multi-line statement."
msgstr ""

#: ../Doc/reference/lexical_analysis.rst:203
msgid "Indentation"
msgstr "Indentation"

#: ../Doc/reference/lexical_analysis.rst:214
msgid ""
"Leading whitespace (spaces and tabs) at the beginning of a logical line is "
"used to compute the indentation level of the line, which in turn is used to "
"determine the grouping of statements."
msgstr ""
"Des espaces ou tabulations au début d’une ligne logique sont utilisées pour "
"connaître le niveau d’indentation de la ligne, qui est ensuite utilisé pour "
"déterminer comment les instructions sont groupées."

#: ../Doc/reference/lexical_analysis.rst:218
msgid ""
"First, tabs are replaced (from left to right) by one to eight spaces such "
"that the total number of characters up to and including the replacement is a "
"multiple of eight (this is intended to be the same rule as used by Unix).  "
"The total number of spaces preceding the first non-blank character then "
"determines the line's indentation.  Indentation cannot be split over "
"multiple physical lines using backslashes; the whitespace up to the first "
"backslash determines the indentation."
msgstr ""

#: ../Doc/reference/lexical_analysis.rst:226
msgid ""
"**Cross-platform compatibility note:** because of the nature of text editors "
"on non-UNIX platforms, it is unwise to use a mixture of spaces and tabs for "
"the indentation in a single source file.  It should also be noted that "
"different platforms may explicitly limit the maximum indentation level."
msgstr ""
"**Note de compatibilité entre les plateformes :** en raison de la nature des "
"éditeurs de texte sur les plateformes non Unix, il n'est pas judicieux "
"d'utiliser un mélange d'espaces et de tabulations pour l'indentation dans un "
"seul fichier source. Il convient également de noter que des plateformes "
"peuvent explicitement limiter le niveau d'indentation maximal."

#: ../Doc/reference/lexical_analysis.rst:231
msgid ""
"A formfeed character may be present at the start of the line; it will be "
"ignored for the indentation calculations above.  Formfeed characters "
"occurring elsewhere in the leading whitespace have an undefined effect (for "
"instance, they may reset the space count to zero)."
msgstr ""
"Un caractère de saut de page peut être présent au début de la ligne ; il est "
"ignoré pour les calculs d'indentation ci-dessus. Les caractères de saut de "
"page se trouvant ailleurs avec les espaces en tête de ligne ont un effet "
"indéfini (par exemple, ils peuvent remettre à zéro le nombre d'espaces)."

#: ../Doc/reference/lexical_analysis.rst:240
msgid ""
"The indentation levels of consecutive lines are used to generate INDENT and "
"DEDENT tokens, using a stack, as follows."
msgstr ""
"Les niveaux d'indentation de lignes consécutives sont utilisés pour générer "
"les lexèmes INDENT et DEDENT, en utilisant une pile, de cette façon :"

#: ../Doc/reference/lexical_analysis.rst:243
msgid ""
"Before the first line of the file is read, a single zero is pushed on the "
"stack; this will never be popped off again.  The numbers pushed on the stack "
"will always be strictly increasing from bottom to top.  At the beginning of "
"each logical line, the line's indentation level is compared to the top of "
"the stack. If it is equal, nothing happens. If it is larger, it is pushed on "
"the stack, and one INDENT token is generated.  If it is smaller, it *must* "
"be one of the numbers occurring on the stack; all numbers on the stack that "
"are larger are popped off, and for each number popped off a DEDENT token is "
"generated.  At the end of the file, a DEDENT token is generated for each "
"number remaining on the stack that is larger than zero."
msgstr ""
"Avant que la première ligne du fichier ne soit lue, un \"zéro\" est posé sur "
"la pile ; il ne sera plus jamais enlevé. Les nombres empilés sont toujours "
"strictement croissants de bas en haut. Au début de chaque ligne logique, le "
"niveau d'indentation de la ligne est comparé au sommet de la pile. S'ils "
"sont égaux, il ne se passe rien. S'il est plus grand, il est empilé et un "
"lexème INDENT est produit. S'il est plus petit, il *doit* être l'un des "
"nombres présents dans la pile ; tous les nombres de la pile qui sont plus "
"grands sont retirés et, pour chaque nombre retiré, un lexème DEDENT est "
"produit. À la fin du fichier, un lexème DEDENT est produit pour chaque "
"nombre supérieur à zéro restant sur la pile."

#: ../Doc/reference/lexical_analysis.rst:254
msgid ""
"Here is an example of a correctly (though confusingly) indented piece of "
"Python code::"
msgstr ""
"Voici un exemple de code Python correctement indenté (bien que très "
"confus) ::"

#: ../Doc/reference/lexical_analysis.rst:269
msgid "The following example shows various indentation errors::"
msgstr "L'exemple suivant montre plusieurs erreurs d'indentation ::"

#: ../Doc/reference/lexical_analysis.rst:279
msgid ""
"(Actually, the first three errors are detected by the parser; only the last "
"error is found by the lexical analyzer --- the indentation of ``return r`` "
"does not match a level popped off the stack.)"
msgstr ""
"En fait, les trois premières erreurs sont détectées par l'analyseur "
"syntaxique ; seule la dernière erreur est trouvée par l'analyseur lexical "
"(l'indentation de ``return r`` ne correspond à aucun niveau dans la pile)."

#: ../Doc/reference/lexical_analysis.rst:287
msgid "Whitespace between tokens"
msgstr "Espaces entre lexèmes"

#: ../Doc/reference/lexical_analysis.rst:289
msgid ""
"Except at the beginning of a logical line or in string literals, the "
"whitespace characters space, tab and formfeed can be used interchangeably to "
"separate tokens.  Whitespace is needed between two tokens only if their "
"concatenation could otherwise be interpreted as a different token (e.g., ab "
"is one token, but a b is two tokens)."
msgstr ""
"Sauf au début d'une ligne logique ou dans les chaînes de caractères, les "
"caractères \"blancs\" espace, tabulation et saut de page peuvent être "
"utilisés de manière interchangeable pour séparer les lexèmes. Un blanc n'est "
"nécessaire entre deux lexèmes que si leur concaténation pourrait être "
"interprétée comme un lexème différent (par exemple, ab est un lexème, mais a "
"b comporte deux lexèmes)."

#: ../Doc/reference/lexical_analysis.rst:299
msgid "Other tokens"
msgstr "Autres lexèmes"

#: ../Doc/reference/lexical_analysis.rst:301
msgid ""
"Besides NEWLINE, INDENT and DEDENT, the following categories of tokens "
"exist: *identifiers*, *keywords*, *literals*, *operators*, and *delimiters*. "
"Whitespace characters (other than line terminators, discussed earlier) are "
"not tokens, but serve to delimit tokens. Where ambiguity exists, a token "
"comprises the longest possible string that forms a legal token, when read "
"from left to right."
msgstr ""
"Outre NEWLINE, INDENT et DEDENT, il existe les catégories de lexèmes "
"suivantes : *identifiants*, *mots clés*, *littéraux*, *opérateurs* et "
"*délimiteurs*. Les blancs (autres que les fins de lignes, vus auparavant) ne "
"sont pas des lexèmes mais servent à délimiter les lexèmes. Quand une "
"ambiguïté existe, le lexème correspond à la plus grande chaîne possible qui "
"forme un lexème licite, en lisant de la gauche vers la droite."

#: ../Doc/reference/lexical_analysis.rst:311
msgid "Identifiers and keywords"
msgstr "Identifiants et mots-clés"

#: ../Doc/reference/lexical_analysis.rst:317
msgid ""
"Identifiers (also referred to as *names*) are described by the following "
"lexical definitions:"
msgstr ""

#: ../Doc/reference/lexical_analysis.rst:327
msgid "Identifiers are unlimited in length.  Case is significant."
msgstr ""
"Les identifiants n'ont pas de limite de longueur. La casse est prise en "
"compte."

#: ../Doc/reference/lexical_analysis.rst:333
msgid "Keywords"
msgstr "Mots-clés"

#: ../Doc/reference/lexical_analysis.rst:339
msgid ""
"The following identifiers are used as reserved words, or *keywords* of the "
"language, and cannot be used as ordinary identifiers.  They must be spelled "
"exactly as written here:"
msgstr ""
"Les identifiants suivants sont des mots réservés par le langage et ne "
"peuvent pas être utilisés en tant qu'identifiants normaux. Ils doivent être "
"écrits exactement comme ci-dessous :"

#: ../Doc/reference/lexical_analysis.rst:353
msgid ""
":const:`None` became a constant and is now recognized by the compiler as a "
"name for the built-in object :const:`None`.  Although it is not a keyword, "
"you cannot assign a different object to it."
msgstr ""

#: ../Doc/reference/lexical_analysis.rst:358
msgid ""
"Using :keyword:`as` and :keyword:`with` as identifiers triggers a warning.  "
"To use them as keywords, enable the ``with_statement`` future feature ."
msgstr ""

#: ../Doc/reference/lexical_analysis.rst:362
msgid ":keyword:`as` and :keyword:`with` are full keywords."
msgstr ""

#: ../Doc/reference/lexical_analysis.rst:369
msgid "Reserved classes of identifiers"
msgstr "Classes réservées pour les identifiants"

#: ../Doc/reference/lexical_analysis.rst:371
msgid ""
"Certain classes of identifiers (besides keywords) have special meanings.  "
"These classes are identified by the patterns of leading and trailing "
"underscore characters:"
msgstr ""
"Certaines classes d'identifiants (outre les mots-clés) ont une signification "
"particulière.  Ces classes se reconnaissent par des caractères de "
"soulignement en tête et en queue d'identifiant :"

#: ../Doc/reference/lexical_analysis.rst:385
msgid "``_*``"
msgstr "``_*``"

#: ../Doc/reference/lexical_analysis.rst:376
msgid ""
"Not imported by ``from module import *``.  The special identifier ``_`` is "
"used in the interactive interpreter to store the result of the last "
"evaluation; it is stored in the :mod:`__builtin__` module.  When not in "
"interactive mode, ``_`` has no special meaning and is not defined. See "
"section :ref:`import`."
msgstr ""

#: ../Doc/reference/lexical_analysis.rst:383
msgid ""
"The name ``_`` is often used in conjunction with internationalization; refer "
"to the documentation for the :mod:`gettext` module for more information on "
"this convention."
msgstr ""
"Le nom ``_`` est souvent utilisé pour internationaliser l'affichage ; "
"reportez-vous à la documentation du module :mod:`gettext` pour plus "
"d'informations sur cette convention."

#: ../Doc/reference/lexical_analysis.rst:393
msgid "``__*__``"
msgstr "``__*__``"

#: ../Doc/reference/lexical_analysis.rst:388
msgid ""
"System-defined names. These names are defined by the interpreter and its "
"implementation (including the standard library).  Current system names are "
"discussed in the :ref:`specialnames` section and elsewhere.  More will "
"likely be defined in future versions of Python.  *Any* use of ``__*__`` "
"names, in any context, that does not follow explicitly documented use, is "
"subject to breakage without warning."
msgstr ""
"Noms définis par le système. Ces noms sont définis par l'interpréteur et son "
"implémentation (y compris la bibliothèque standard). Les noms actuels "
"définis par le système sont abordés dans la section :ref:`specialnames`, "
"mais aussi ailleurs. D'autres noms seront probablement définis dans les "
"futures versions de Python. Toute utilisation de noms de la forme ``__*__``, "
"dans n'importe quel contexte, qui n'est pas conforme à ce qu'indique "
"explicitement la documentation, est sujette à des mauvaises surprises sans "
"avertissement."

#: ../Doc/reference/lexical_analysis.rst:400
msgid "``__*``"
msgstr "``__*``"

#: ../Doc/reference/lexical_analysis.rst:396
msgid ""
"Class-private names.  Names in this category, when used within the context "
"of a class definition, are re-written to use a mangled form to help avoid "
"name clashes between \"private\" attributes of base and derived classes. See "
"section :ref:`atom-identifiers`."
msgstr ""
"Noms privés pour une classe.  Les noms de cette forme, lorsqu'ils sont "
"utilisés dans le contexte d'une définition de classe, sont réécrits sous une "
"forme modifiée pour éviter les conflits de noms entre les attributs \"privés"
"\" des classes de base et les classes dérivées. Voir la section :ref:`atom-"
"identifiers`."

#: ../Doc/reference/lexical_analysis.rst:405
msgid "Literals"
msgstr "Littéraux"

#: ../Doc/reference/lexical_analysis.rst:411
msgid "Literals are notations for constant values of some built-in types."
msgstr ""
"Les littéraux sont des notations pour indiquer des valeurs constantes de "
"certains types natifs."

#: ../Doc/reference/lexical_analysis.rst:417
msgid "String literals"
msgstr ""

#: ../Doc/reference/lexical_analysis.rst:421
msgid "String literals are described by the following lexical definitions:"
msgstr ""
"Les chaînes de caractères littérales sont définies par les définitions "
"lexicales suivantes :"

#: ../Doc/reference/lexical_analysis.rst:438
msgid ""
"One syntactic restriction not indicated by these productions is that "
"whitespace is not allowed between the :token:`stringprefix` and the rest of "
"the string literal. The source character set is defined by the encoding "
"declaration; it is ASCII if no encoding declaration is given in the source "
"file; see section :ref:`encodings`."
msgstr ""

#: ../Doc/reference/lexical_analysis.rst:450
msgid ""
"In plain English: String literals can be enclosed in matching single quotes "
"(``'``) or double quotes (``\"``).  They can also be enclosed in matching "
"groups of three single or double quotes (these are generally referred to as "
"*triple-quoted strings*).  The backslash (``\\``) character is used to "
"escape characters that otherwise have a special meaning, such as newline, "
"backslash itself, or the quote character.  String literals may optionally be "
"prefixed with a letter ``'r'`` or ``'R'``; such strings are called :dfn:`raw "
"strings` and use different rules for interpreting backslash escape "
"sequences.  A prefix of ``'u'`` or ``'U'`` makes the string a Unicode "
"string.  Unicode strings use the Unicode character set as defined by the "
"Unicode Consortium and ISO 10646.  Some additional escape sequences, "
"described below, are available in Unicode strings. A prefix of ``'b'`` or "
"``'B'`` is ignored in Python 2; it indicates that the literal should become "
"a bytes literal in Python 3 (e.g. when code is automatically converted with "
"2to3).  A ``'u'`` or ``'b'`` prefix may be followed by an ``'r'`` prefix."
msgstr ""

#: ../Doc/reference/lexical_analysis.rst:466
msgid ""
"In triple-quoted strings, unescaped newlines and quotes are allowed (and are "
"retained), except that three unescaped quotes in a row terminate the "
"string.  (A \"quote\" is the character used to open the string, i.e. either "
"``'`` or ``\"``.)"
msgstr ""

#: ../Doc/reference/lexical_analysis.rst:476
msgid ""
"Unless an ``'r'`` or ``'R'`` prefix is present, escape sequences in strings "
"are interpreted according to rules similar to those used by Standard C.  The "
"recognized escape sequences are:"
msgstr ""

#: ../Doc/reference/lexical_analysis.rst:481
msgid "Escape Sequence"
msgstr "Séquence d'échappement"

#: ../Doc/reference/lexical_analysis.rst:481
msgid "Meaning"
msgstr "Signification"

#: ../Doc/reference/lexical_analysis.rst:481
msgid "Notes"
msgstr "Notes"

#: ../Doc/reference/lexical_analysis.rst:483
msgid "``\\newline``"
msgstr "``\\newline``"

#: ../Doc/reference/lexical_analysis.rst:483
msgid "Ignored"
msgstr "Ignoré"

#: ../Doc/reference/lexical_analysis.rst:485
msgid "``\\\\``"
msgstr "``\\\\``"

#: ../Doc/reference/lexical_analysis.rst:485
msgid "Backslash (``\\``)"
msgstr "barre oblique inversée (``\\``)"

#: ../Doc/reference/lexical_analysis.rst:487
msgid "``\\'``"
msgstr "``\\'``"

#: ../Doc/reference/lexical_analysis.rst:487
msgid "Single quote (``'``)"
msgstr "guillemet simple  (``'``)"

#: ../Doc/reference/lexical_analysis.rst:489
msgid "``\\\"``"
msgstr "``\\\"``"

#: ../Doc/reference/lexical_analysis.rst:489
msgid "Double quote (``\"``)"
msgstr "guillemet double (``\"``)"

#: ../Doc/reference/lexical_analysis.rst:491
msgid "``\\a``"
msgstr "``\\a``"

#: ../Doc/reference/lexical_analysis.rst:491
msgid "ASCII Bell (BEL)"
msgstr "cloche ASCII (BEL)"

#: ../Doc/reference/lexical_analysis.rst:493
msgid "``\\b``"
msgstr "``\\b``"

#: ../Doc/reference/lexical_analysis.rst:493
msgid "ASCII Backspace (BS)"
msgstr "retour arrière ASCII (BS)"

#: ../Doc/reference/lexical_analysis.rst:495
msgid "``\\f``"
msgstr "``\\f``"

#: ../Doc/reference/lexical_analysis.rst:495
msgid "ASCII Formfeed (FF)"
msgstr "saut de page ASCII (FF)"

#: ../Doc/reference/lexical_analysis.rst:497
msgid "``\\n``"
msgstr "``\\n``"

#: ../Doc/reference/lexical_analysis.rst:497
msgid "ASCII Linefeed (LF)"
msgstr "saut de ligne ASCII (LF)"

#: ../Doc/reference/lexical_analysis.rst:499
msgid "``\\N{name}``"
msgstr "``\\N{name}``"

#: ../Doc/reference/lexical_analysis.rst:499
msgid "Character named *name* in the Unicode database (Unicode only)"
msgstr ""

#: ../Doc/reference/lexical_analysis.rst:502
msgid "``\\r``"
msgstr "``\\r``"

#: ../Doc/reference/lexical_analysis.rst:502
msgid "ASCII Carriage Return (CR)"
msgstr "retour à la ligne ASCII (CR)"

#: ../Doc/reference/lexical_analysis.rst:504
msgid "``\\t``"
msgstr "``\\t``"

#: ../Doc/reference/lexical_analysis.rst:504
msgid "ASCII Horizontal Tab (TAB)"
msgstr "tabulation horizontale ASCII (TAB)"

#: ../Doc/reference/lexical_analysis.rst:506
msgid "``\\uxxxx``"
msgstr "``\\uxxxx``"

#: ../Doc/reference/lexical_analysis.rst:506
msgid "Character with 16-bit hex value *xxxx* (Unicode only)"
msgstr ""

#: ../Doc/reference/lexical_analysis.rst:506
msgid "\\(1)"
msgstr "\\(1)"

#: ../Doc/reference/lexical_analysis.rst:509
msgid "``\\Uxxxxxxxx``"
msgstr "``\\Uxxxxxxxx``"

#: ../Doc/reference/lexical_analysis.rst:509
msgid "Character with 32-bit hex value *xxxxxxxx* (Unicode only)"
msgstr ""

#: ../Doc/reference/lexical_analysis.rst:509
msgid "\\(2)"
msgstr "\\(2)"

#: ../Doc/reference/lexical_analysis.rst:512
msgid "``\\v``"
msgstr "``\\v``"

#: ../Doc/reference/lexical_analysis.rst:512
msgid "ASCII Vertical Tab (VT)"
msgstr "tabulation verticale ASCII (VT)"

#: ../Doc/reference/lexical_analysis.rst:514
msgid "``\\ooo``"
msgstr "``\\ooo``"

#: ../Doc/reference/lexical_analysis.rst:514
msgid "Character with octal value *ooo*"
msgstr "caractère dont le code est *ooo* en octal"

#: ../Doc/reference/lexical_analysis.rst:514
msgid "(3,5)"
msgstr ""

#: ../Doc/reference/lexical_analysis.rst:517
msgid "``\\xhh``"
msgstr "``\\xhh``"

#: ../Doc/reference/lexical_analysis.rst:517
msgid "Character with hex value *hh*"
msgstr "caractère dont le code est *ooo* en hexadécimal"

#: ../Doc/reference/lexical_analysis.rst:517
msgid "(4,5)"
msgstr ""

#: ../Doc/reference/lexical_analysis.rst:522
msgid "Notes:"
msgstr "Notes :"

#: ../Doc/reference/lexical_analysis.rst:525
msgid ""
"Individual code units which form parts of a surrogate pair can be encoded "
"using this escape sequence."
msgstr ""

#: ../Doc/reference/lexical_analysis.rst:529
msgid ""
"Any Unicode character can be encoded this way, but characters outside the "
"Basic Multilingual Plane (BMP) will be encoded using a surrogate pair if "
"Python is compiled to use 16-bit code units (the default)."
msgstr ""

#: ../Doc/reference/lexical_analysis.rst:534
msgid "As in Standard C, up to three octal digits are accepted."
msgstr ""
"Comme dans le C Standard, jusqu'à trois chiffres en base huit sont acceptés."

#: ../Doc/reference/lexical_analysis.rst:537
msgid "Unlike in Standard C, exactly two hex digits are required."
msgstr ""
"Contrairement au C Standard, il est obligatoire de fournir deux chiffres "
"hexadécimaux."

#: ../Doc/reference/lexical_analysis.rst:540
msgid ""
"In a string literal, hexadecimal and octal escapes denote the byte with the "
"given value; it is not necessary that the byte encodes a character in the "
"source character set. In a Unicode literal, these escapes denote a Unicode "
"character with the given value."
msgstr ""

#: ../Doc/reference/lexical_analysis.rst:547
msgid ""
"Unlike Standard C, all unrecognized escape sequences are left in the string "
"unchanged, i.e., *the backslash is left in the string*.  (This behavior is "
"useful when debugging: if an escape sequence is mistyped, the resulting "
"output is more easily recognized as broken.)  It is also important to note "
"that the escape sequences marked as \"(Unicode only)\" in the table above "
"fall into the category of unrecognized escapes for non-Unicode string "
"literals."
msgstr ""

#: ../Doc/reference/lexical_analysis.rst:554
msgid ""
"When an ``'r'`` or ``'R'`` prefix is present, a character following a "
"backslash is included in the string without change, and *all backslashes are "
"left in the string*.  For example, the string literal ``r\"\\n\"`` consists "
"of two characters: a backslash and a lowercase ``'n'``.  String quotes can "
"be escaped with a backslash, but the backslash remains in the string; for "
"example, ``r\"\\\"\"`` is a valid string literal consisting of two "
"characters: a backslash and a double quote; ``r\"\\\"`` is not a valid "
"string literal (even a raw string cannot end in an odd number of "
"backslashes).  Specifically, *a raw string cannot end in a single backslash* "
"(since the backslash would escape the following quote character).  Note also "
"that a single backslash followed by a newline is interpreted as those two "
"characters as part of the string, *not* as a line continuation."
msgstr ""

#: ../Doc/reference/lexical_analysis.rst:567
msgid ""
"When an ``'r'`` or ``'R'`` prefix is used in conjunction with a ``'u'`` or "
"``'U'`` prefix, then the ``\\uXXXX`` and ``\\UXXXXXXXX`` escape sequences "
"are processed while  *all other backslashes are left in the string*. For "
"example, the string literal ``ur\"\\u0062\\n\"`` consists of three Unicode "
"characters: 'LATIN SMALL LETTER B', 'REVERSE SOLIDUS', and 'LATIN SMALL "
"LETTER N'. Backslashes can be escaped with a preceding backslash; however, "
"both remain in the string.  As a result, ``\\uXXXX`` escape sequences are "
"only recognized when there are an odd number of backslashes."
msgstr ""

#: ../Doc/reference/lexical_analysis.rst:580
msgid "String literal concatenation"
msgstr "Concaténation de chaînes de caractères"

#: ../Doc/reference/lexical_analysis.rst:582
msgid ""
"Multiple adjacent string literals (delimited by whitespace), possibly using "
"different quoting conventions, are allowed, and their meaning is the same as "
"their concatenation.  Thus, ``\"hello\" 'world'`` is equivalent to ``"
"\"helloworld\"``.  This feature can be used to reduce the number of "
"backslashes needed, to split long strings conveniently across long lines, or "
"even to add comments to parts of strings, for example::"
msgstr ""

#: ../Doc/reference/lexical_analysis.rst:593
msgid ""
"Note that this feature is defined at the syntactical level, but implemented "
"at compile time.  The '+' operator must be used to concatenate string "
"expressions at run time.  Also note that literal concatenation can use "
"different quoting styles for each component (even mixing raw strings and "
"triple quoted strings)."
msgstr ""

#: ../Doc/reference/lexical_analysis.rst:602
msgid "Numeric literals"
msgstr "Littéraux numériques"

#: ../Doc/reference/lexical_analysis.rst:618
msgid ""
"There are four types of numeric literals: plain integers, long integers, "
"floating point numbers, and imaginary numbers.  There are no complex "
"literals (complex numbers can be formed by adding a real number and an "
"imaginary number)."
msgstr ""

#: ../Doc/reference/lexical_analysis.rst:622
msgid ""
"Note that numeric literals do not include a sign; a phrase like ``-1`` is "
"actually an expression composed of the unary operator '``-``' and the "
"literal ``1``."
msgstr ""
"Notez que les littéraux numériques ne comportent pas de signe ; une phrase "
"telle que ``-1`` est en fait une expression composée de l'opérateur unitaire "
"``-`` et du littéral ``1``."

#: ../Doc/reference/lexical_analysis.rst:630
msgid "Integer and long integer literals"
msgstr ""

#: ../Doc/reference/lexical_analysis.rst:632
msgid ""
"Integer and long integer literals are described by the following lexical "
"definitions:"
msgstr ""

#: ../Doc/reference/lexical_analysis.rst:647
msgid ""
"Although both lower case ``'l'`` and upper case ``'L'`` are allowed as "
"suffix for long integers, it is strongly recommended to always use ``'L'``, "
"since the letter ``'l'`` looks too much like the digit ``'1'``."
msgstr ""

#: ../Doc/reference/lexical_analysis.rst:651
msgid ""
"Plain integer literals that are above the largest representable plain "
"integer (e.g., 2147483647 when using 32-bit arithmetic) are accepted as if "
"they were long integers instead. [#]_  There is no limit for long integer "
"literals apart from what can be stored in available memory."
msgstr ""

#: ../Doc/reference/lexical_analysis.rst:656
msgid ""
"Some examples of plain integer literals (first row) and long integer "
"literals (second and third rows)::"
msgstr ""

#: ../Doc/reference/lexical_analysis.rst:667
msgid "Floating point literals"
msgstr "Nombres à virgule flottante littéraux"

#: ../Doc/reference/lexical_analysis.rst:669
msgid ""
"Floating point literals are described by the following lexical definitions:"
msgstr ""
"Les nombres à virgule flottante littéraux sont décrits par les définitions "
"lexicales suivantes :"

#: ../Doc/reference/lexical_analysis.rst:679
msgid ""
"Note that the integer and exponent parts of floating point numbers can look "
"like octal integers, but are interpreted using radix 10.  For example, "
"``077e010`` is legal, and denotes the same number as ``77e10``. The allowed "
"range of floating point literals is implementation-dependent. Some examples "
"of floating point literals::"
msgstr ""

#: ../Doc/reference/lexical_analysis.rst:687
msgid ""
"Note that numeric literals do not include a sign; a phrase like ``-1`` is "
"actually an expression composed of the unary operator ``-`` and the literal "
"``1``."
msgstr ""

#: ../Doc/reference/lexical_analysis.rst:695
msgid "Imaginary literals"
msgstr "Imaginaires littéraux"

#: ../Doc/reference/lexical_analysis.rst:697
msgid "Imaginary literals are described by the following lexical definitions:"
msgstr ""
"Les nombres imaginaires sont décrits par les définitions lexicales "
"suivantes :"

#: ../Doc/reference/lexical_analysis.rst:702
msgid ""
"An imaginary literal yields a complex number with a real part of 0.0.  "
"Complex numbers are represented as a pair of floating point numbers and have "
"the same restrictions on their range.  To create a complex number with a "
"nonzero real part, add a floating point number to it, e.g., ``(3+4j)``.  "
"Some examples of imaginary literals::"
msgstr ""
"Un littéral imaginaire produit un nombre complexe dont la partie réelle est "
"``0.0``. Les nombres complexes sont représentés comme une paire de nombres à "
"virgule flottante et possèdent les mêmes restrictions concernant les plages "
"autorisées. Pour créer un nombre complexe dont la partie réelle est non "
"nulle, ajoutez un nombre à virgule flottante à votre littéral imaginaire. "
"Par exemple ``(3+4j)``. Voici d'autres exemples de littéraux imaginaires ::"

#: ../Doc/reference/lexical_analysis.rst:714
msgid "Operators"
msgstr "Opérateurs"

#: ../Doc/reference/lexical_analysis.rst:718
msgid "The following tokens are operators:"
msgstr "Les lexèmes suivants sont des opérateurs :"

#: ../Doc/reference/lexical_analysis.rst:727
msgid ""
"The comparison operators ``<>`` and ``!=`` are alternate spellings of the "
"same operator.  ``!=`` is the preferred spelling; ``<>`` is obsolescent."
msgstr ""

#: ../Doc/reference/lexical_analysis.rst:734
msgid "Delimiters"
msgstr "Délimiteurs"

#: ../Doc/reference/lexical_analysis.rst:738
msgid "The following tokens serve as delimiters in the grammar:"
msgstr "Les lexèmes suivants servent de délimiteurs dans la grammaire :"

#: ../Doc/reference/lexical_analysis.rst:747
msgid ""
"The period can also occur in floating-point and imaginary literals.  A "
"sequence of three periods has a special meaning as an ellipsis in slices. "
"The second half of the list, the augmented assignment operators, serve "
"lexically as delimiters, but also perform an operation."
msgstr ""

#: ../Doc/reference/lexical_analysis.rst:752
msgid ""
"The following printing ASCII characters have special meaning as part of "
"other tokens or are otherwise significant to the lexical analyzer:"
msgstr ""
"Les caractères ASCII suivants ont une signification spéciale en tant que "
"partie d'autres lexèmes ou ont une signification particulière pour  "
"l'analyseur lexical :"

#: ../Doc/reference/lexical_analysis.rst:761
msgid ""
"The following printing ASCII characters are not used in Python.  Their "
"occurrence outside string literals and comments is an unconditional error:"
msgstr ""
"Les caractères ASCII suivants ne sont pas utilisés en Python. S'ils "
"apparaissent en dehors de chaines littérales ou de commentaires, ils "
"produisent une erreur :"

#: ../Doc/reference/lexical_analysis.rst:769
msgid "Footnotes"
msgstr "Notes"

#: ../Doc/reference/lexical_analysis.rst:770
msgid ""
"In versions of Python prior to 2.4, octal and hexadecimal literals in the "
"range just above the largest representable plain integer but below the "
"largest unsigned 32-bit number (on a machine using 32-bit arithmetic), "
"4294967296, were taken as the negative plain integer obtained by subtracting "
"4294967296 from their unsigned value."
msgstr ""
